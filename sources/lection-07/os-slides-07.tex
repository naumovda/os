\documentclass{beamer}
\mode<presentation>
\usetheme{CambridgeUS}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{sansmathaccent}

\usepackage{verbatim}
\usepackage{alltt}

\pdfmapfile{+sansmathaccent.map}
\title[Язык C]{Управление процессами, часть 6}
\author{Наумов Д.А., доц. каф. КТ}
\date[15.10.2019] {Операционные системы и системное программное обеспечение, 2019}

\begin{document}

%ТИТУЛЬНЫЙ СЛАЙД
\begin{frame}
  \titlepage
\end{frame}
  
%СОДЕРЖАНИЕ ЛЕКЦИИ
\begin{frame}
  \frametitle{Содержание лекции}
  \tableofcontents  
\end{frame}

\section{Основные понятия}

\begin{frame}{Программы, процессы и потоки}
\begin{block}{Бинарный модуль (программа, приложение)}
компилированный, исполняемый код, находящийся в каком-либо хранилище данных, например на диске.
\end{block}
\begin{block}{Процесс}
запущенная программа.
\end{block}
Процесс включает в себя:
\begin{itemize}
\item бинарный образ, загружаемый в память;
\item подгрузку виртуальной памяти;
\item ресурсы ядра (открытые файлы, выполнение требований по безопасности);
\item запуск одного или нескольких потоков.
\end{itemize}
\textbf{Поток} - это одно из действий внутри процесса. Поток
имеет собственный виртуализированный процессор, включающий в себя стек,
состояние процессора, например регистры, а также командные указатели.
\end{frame}

\section{Идентификаторы процессов}

\begin{frame}{Идентификатор процесса}
\begin{block}{Идентификатор процесса (process ID, pid)}
уникальное (в любой конкретный момент времени) число, обозначающее процесс
\end{block}
\begin{itemize}
\item процесс бездействия (idle process) - pid = 0;
\end{itemize}
\begin{block}{Процесс инициализации}
первый процесс, который ядро выполняет во время запуска системы, pid = 1
\end{block}
\begin{itemize}
\item /sbin/init - наиболее вероятное размещение процесса инициализации 
\item /etc/init - следующее вероятное размещение процесса инициализации
\item /bin/init - резервное размещение процесса инициализации
\item /bin/sh - местонахождение оболочки Bourne, которую ядро пытается запустить
\end{itemize}
\end{frame}

\begin{frame}{Идентификатор процесса}
\begin{block}{pid\_t}
С точки зрения программирования идентификатор процесса обозначается типом
pid\_t, величина которого определяется в заголовочном файле <<sys/types.h>>. 
\end{block}
Выделение идентификатора процесса
\begin{itemize}
\item максимальное значение - /proc/sys/kernel/pid\_max
\item идентификаторы назначаются линейно
\item ранее исползованные индентификаторы не назначаются, пока не будет достигнуто pid\_max 
\end{itemize}
\end{frame}

\begin{frame}{Иерархия процессов, пользователи, группы}
Процесс, запускающий другой процесс, называется \textbf{родительским}; новый процесс, таким образом, является \textbf{дочерним}.
\begin{itemize}
\item каждый процесс запускается каким­либо другим процессом (кроме, разумеется, процессов инициализации). 
\item каждый дочерний процесс имеет <<родителя>>. 
\item идентификатор родительского процесса - \textbf{ppid}.
\item каждый процесс принадлежит определенному \textbf{пользователю} и \textbf{группе}. Эти принадлежности используются для управления правами доступа к ресурсам. 
\item каждый дочерний процесс наследует пользователя и группу, которым принадлежал родительский процесс.
\item каждый процесс является также частью \textbf{группы процессов}. Дочерние процессы, как правило, принадлежат к тем же группам процессов, что и родительские.
(Пример: \textit{ls | less}) 
\end{itemize}
\end{frame}

\begin{frame}{Иерархия процессов, пользователи, группы}
Для получения информации о процессах предназначена программа ps, поддерживающая большое количество опций.

Если вызвать ps без аргументов, то на экране появится список процессов, запущенных под текущим терминалом:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic22.png}
\end{figure}
\begin{itemize}
\item Первый столбец (PID) - идентификатор процесса. 
\item Второй и третий столбцы (TTY и TIME) пока не рассматриваемм. 
\item В четвертом столбце (CMD) записывается имя исполняемого файла программы, запущенной внутри процесса.
\end{itemize}
\end{frame}

\begin{frame}
Если теперь запустить под оболочкой какую-нибудь программу, то она будет связана с текущим терминалом и появится в выводе программы ps. 
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic23.png}
\end{figure}
Прерываем выполнение фоновой команды
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic24.png}
\end{figure}
\end{frame}

\begin{frame}
Если вызвать программу ps с опцией -f, то вывод пополнится несколькими новыми
столбцами: 
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic25.png}
\end{figure}
\begin{itemize}
\item В столбце PPID выводится идентификатор родительского процесса.
\item Cтолбец UID (User IDentifier) в расширенном выводе программы ps содержит
имя пользователя, от лица которого запущен процесс.
\end{itemize}
\end{frame}

\begin{frame}
Чтобы узнать числовой UID текущего пользователя, можно выполнить следующую
команду:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic26.png}
\end{figure}
Можно также узнать UID любого пользователя системы:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic27.png}
\end{figure}
UID суперпользователя (с именем root в подавляющем большинстве случаев) всегда равен 0:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic28.png}
\end{figure}
\end{frame}

\begin{frame}
Получение имени пользователя из числового id:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic29.png}
\end{figure}
Программа getpinfo
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic30.png}
\end{figure}
\end{frame}

\begin{frame}{Получение идентификатора процесса}
Системный вызов getpid() возвращает идентификатор вызывающего процесса:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic01.png}
\end{figure}
Системный вызов getppid() возвращает идентификатор родителя вызывающего процесса:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic02.png}
\end{figure}
Ни один из них не может вернуть ошибку:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic03.png}
\end{figure}
\end{frame}

\section{Запуск нового процесса}

\begin{frame}
Самый простой способ породить в Linux новый процесс — вызвать библиотечную
функцию  system(), которая просто передает команду в оболочку, на которую ссылается файл /bin/sh:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic17.png}
\end{figure}
Работа функции system:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic18.png}
\end{figure}
Результат:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic19.png}
\end{figure}
\end{frame}

\begin{frame}
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic20.png}
\end{figure}
Работа функции system:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic21.png}
\end{figure}
\begin{itemize}
\item system() ожидает завершения переданной ей команды. Поэтому сообщение "endof-program" выводится на экран примерно через 5 с;
\item в system() можно передавать не только имя программы, но и аргументы.
\end{itemize}
\end{frame}

\begin{frame}{Запуск нового процесса}
В UNIX действие загрузки в память и запуска образа программы выполняется
отдельно от операции по созданию нового процесса:
\begin{itemize}
\item один системный вызов (exec) загружает бинарную программу в память, замещая текущее содержание адресного пространства, и начинает выполнение новой программы. 
\item другой системный вызов (fork) используется для создания нового процесса, который изначально является практически копией своего родительского.
\end{itemize}
\end{frame}

\begin{frame}{Системный вызов fork()}
Новый процесс, запускающий тот же системный образ, что и текущий, может быть
создан с помощью системного вызова fork():
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic07.png}
\end{figure}
\begin{itemize}
\item В случае успешного обращения к fork() создается новый процесс, во всех отношениях идентичный вызывающему. 
\item Оба процесса выполняются от точки обращения к fork(), как будто ничего не происходило.
\end{itemize}
\end{frame}

\begin{frame}{Пример fork()}
Программа:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic31.png}
\end{figure}
Результат:
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic32.png}
\end{figure}
\end{frame}

\begin{frame}{Системный вызов fork()}
В дочернем процессе успешный запуск \textbf{fork()} возвращает \textbf{0}. В родительском \textbf{fork()} возвращает \textbf{pid} дочернего. 

Родительский и дочерний процессы практически идентичны, за исключением некоторых особенностей:
\begin{itemize}
\item pid дочернего процесса назначается заново и отличается от родительского;
\item родительский pid дочернего процесса установлен равным pid родительского
процесса;
\item ресурсная статистика дочернего процесса обнуляется;
\item любые ожидающие сигналы прерываются и не наследуются дочерним процессом;
\item никакие вовлеченные блокировки файлов не наследуются дочерним процессом.
\end{itemize}
\end{frame}

\begin{frame}{Пример fork()}
Программа:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic33.png}
\end{figure}
Результат:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic34.png}
\end{figure}
\end{frame}

\begin{frame}{Переключения процессов}
Программа:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic35.png}
\end{figure}
\end{frame}

\begin{frame}{Системный вызов fork()}
В случае ошибки дочерний процесс не создается, fork() возвращает –1, устанавливая соответствующее значение errno. 

Вот два возможных значения errno и их
смысл:
\begin{itemize}
\item EAGAIN — ядро не способно выделить определенные ресурсы, например новый
pid, или достигнуто ограничение по ресурсам RLIMIT\_NPROC;
\item ENOMEM — недостаточно ресурсов памяти ядра, чтобы завершить запрос.
\end{itemize}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic08.png}
\end{figure}
\end{frame}

\begin{frame}{Системный вызов fork()}
Чаще всего системный вызов fork() используется для создания нового процесса
и последующей загрузки в него нового двоичного образа.  Сначала процесс ответвляет новый процесс, а потом дочерний процесс создает новый двоичный образ.
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic09.png}
\end{figure}
\end{frame}

\begin{frame}{Семейство вызовов exec}
Единой функции exec не существует; на одном системном вызове построено целое
семейство таких функций. Рассмотрим execl:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic04.png}
\end{figure}
\begin{itemize}
\item вызов execl() замещает текущий образ процесса новым, загружая в память
программу, определенную path. 
\item параметр arg — первый аргумент этой программы. 
\item Многоточие означает переменное количество аргументов — у функции
execl() их количество может быть любым
\item дополнительные аргументы можно указывать в скобках один за другим
\item список аргументов всегда завершается значением NULL.
\end{itemize}
\end{frame}

\begin{frame}{Семейство вызовов exec}
Следующий программный код замещает выполняющуюся в настоящий момент программу с /bin/vi:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic05.png}
\end{figure}
Если вы хотите редактировать файл /home/kidd/hooks.txt, то должны запустить следующий код:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic06.png}
\end{figure}
\end{frame}

\begin{frame}{Семейство вызовов exec}
\begin{itemize}
\item при успешном вызове execl() не возвращает никаких значений 
\item если произошла ошибка, execl() возвращает –1 и устанавливает errno.
\end{itemize}
В случае успешного выполнения вызов execl():
\begin{itemize}
\item изменяет адресное пространство и образ процесса;
\item любые ожидающие сигналы исчезают;
\item любые сигналы, отлавливаемые процессом, возвращаются к своему
поведению по умолчанию;
\item все блокировки памяти удаляются;
\item большинство атрибутов потока возвращается к значениям по умолчанию;
\item большая часть статистических данных процесса сбрасывается;
\item все адресное пространство памяти, относящееся к данному процессу, включая
загруженные файлы, очищается.
\end{itemize}
\end{frame}

\begin{frame}{Семейство вызовов exec}
\begin{itemize}
\item execl, execlp, execle  
\item execv, execvp, execve
\end{itemize}
<<Расшифровка>> названий функций:
\begin{itemize}
\item \textbf{l} и \textbf{v} указывают, передаются ли аргументы списком или массивом. 
\item \textbf{p} указывает, что система будет искать указанный файл по
полному пользовательскому пути. 
\item \textbf{е} обозначает, что для нового процесса создается новое окружение.
\end{itemize}
\end{frame}

\begin{frame}{Семейство вызовов exec}
В прогремме образ текущего процесса заменяется программой
/bin/uname с опцией -a. Если программа была успешно вызвана (независимо от того,
как она завершилась), то сообщение "Error" не выводится. 
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic36.png}
\end{figure}
\end{frame}

\begin{frame}{Пример: окружение, аргументы}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic37.png}
\end{figure}
\end{frame}

\begin{frame}{Пример: окружение, аргументы}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic38.png}
\end{figure}
\end{frame}

\begin{frame}{Пример: окружение, аргументы}
Результат:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic39.png}
\end{figure}
Данный пример демонстрирует сразу три аспекта работы системного вызова
execve():
\begin{itemize}
\item обе программы выполнялись в одном и том же процессе;
\item при помощи системного вызова execve() программе можно "подсунуть" любое окружение;
\item в элементе argv[0] действительно может быть все, что угодно.
\end{itemize}
\end{frame}

\begin{frame}{Пример: совместный вызов fork и exec}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic40.png}
\end{figure}
\end{frame}

\begin{frame}{Пример: совместный вызов fork и exec}
Результат
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic41.png}
\end{figure}
\begin{itemize}
\item Программа породила новый процесс и запустила в нем программу
/bin/sleep, которая дает нам возможность в течение 15 с набрать команду ps и насладиться наличием в системе отдельного процесса.
\item Сообщение <<I'm parent with PID=...>> выводится в стандартный поток ошибок
(stderr), хотя фактически не является ошибкой. Это искусственный прием, позволяющий выводить сообщение на экран немедленно, не задумываясь о возможных
последствиях буферизации стандартного вывода.
\end{itemize}
\end{frame}

\section{Завершение процесса}

\begin{frame}{Завершение процесса}
POSIX и C89 определяют следующую стандартную функцию для завершения текущего процесса:
\begin{itemize}
\item вызов exit() выполняет некоторые основные шаги перед завершением, а затем
отправляет ядру команду прекратить процесс.
\item параметр status используется для обозначения статуса процесса завершения.
\item значения EXIT\_SUCCESS и EXIT\_FAILURE определяются в качестве способов представления успеха и неудачи. 
\end{itemize}
Перед тем как прервать процесс, библиотека C выполняет подготовительные
шаги в следующем порядке.
\begin{enumerate}
\item Вызов всех функций, зарегистрированных с atexit() или on\_exit(), в порядке,
обратном порядку регистрации.
\item Сброс всех стандартных потоков ввода­вывода.
\item Удаление всех временных файлов, созданных функцией tmpfile().
\end{enumerate}
\end{frame}

\begin{frame}{Завершение процесса}
Другие способы завершения:
\begin{itemize}
\item достижение конечной точки программы (системный выхов exit - неявный);
\item полезно возвращать статус выхода явно;
\item процесс также может завершиться, если ему отправлен сигнал, действие которого по умолчанию - окончание процесса (SIGTERM и SIGKILL);
\item ядро может прервать процесс, выполняющий недопустимые инструкции, нарушающий сегментацию, исчерпавший ресурсы памяти и т. д.
\end{itemize}
\end{frame}

\begin{frame}{atexit()}
POSIX 1003.1­2001 определяет, а Linux поддерживает библиотечный вызов atexit(),
используемый для регистрации функций, вызываемых при завершении процесса:
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic11.png}
\end{figure}
\begin{itemize}
\item При успешном срабатывании atexit() регистрирует указанную функцию для
запуска при нормальном завершении процесса, то есть с помощью системного
вызова exit() или возврата результатов функцией main(). 
\item Если процесс запускает функцию exec, список зарегистрированных функций очищается (поскольку функции больше не существуют в новом адресном пространстве процесса). 
\item Если процесс прерывается сигналом, зарегистрированные функции не вызываются.
\end{itemize}
\end{frame}

\section{Ожидание завершения процесса}

\begin{frame}{Ожилание завершения процесса}
Процессы в Linux работают независимо друг от друга, но иногда встает задача организации последовательного выполнения процессов.
\begin{itemize}
\item Пример 1: реализация последовательного выполнения процессов — ожидание родителем завершения своего потомка. Если мы запускаем программу не в фоновом режиме, то оболочка не выдаст приглашение командной строки до тех пор, пока данная программа не завершится.
\item Пример 2: последовательный запуск родительским процессом двух и
более потомков. Например, многие командные оболочки позволяют разделять несколько команд точкой с запятой, организовывая тем самым их последовательное
выполнение (sleep 5 ; ls /).
\end{itemize}
\end{frame}

\begin{frame}{Ожилание завершения процесса}
Когда дочерний процесс завершается прежде родительского, ядро должно поместить потомка в особый процессный статус. 
\begin{itemize}
\item Процесс в этом состоянии известен как \textbf{зомби}. 
\item В данном состоянии существует лишь «скелет» процесса — некоторые основные структуры данных, содержащие потенциально нужные сведения. 
\item Процесс в таком состоянии ожидает запроса о своем статусе от предка (процедура, известная как ожидание процесса­зомби). 
\item Только после того как предок получит всю необходимую информацию о завершенном дочернем процессе, последний формально удаляется и перестает существовать даже в статусе зомби.
\end{itemize}
\end{frame}

\begin{frame}{Интерфейс получения информации о завершении процесса}
Ядро Linux предоставляет несколько интерфейсов для получения информации
о завершенном дочернем процессе. Самый простой из них, определенный POSIX,
называется wait(): 
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic12.png}
\end{figure}
\begin{itemize}
\item Вызов wait() возвращает pid завершенного дочернего процесса или –1 в случае
ошибки. 
\item Если никакого дочернего процесса не было прервано, вызов блокируется,
пока потомок не завершится. 
\item Если дочерний процесс уже был завершен, вызов возвращает результаты немедленно.
\end{itemize}
В случае ошибки возможно присвоение переменной errno одного из двух значений:
\begin{itemize}
\item ECHILD - вызывающий процесс не имеет дочерних;
\item EINTR - сигнал был получен во время ожидания, в результате чего вызов вернул
результат слишком рано.
\end{itemize}
\end{frame}

\begin{frame}{Интерфейс получения информации о завершении процесса}
В случае ошибки возможно присвоение переменной errno одного из двух значений:
\begin{itemize}
\item ECHILD - вызывающий процесс не имеет дочерних;
\item EINTR - сигнал был получен во время ожидания, в результате чего вызов вернул
результат слишком рано.
\end{itemize}
Если указатель status не содержит значения NULL, там находится дополнительная
информация о дочернем процессе. 
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic13.png}
\end{figure}
\end{frame}

\begin{frame}
Статус завершившегося потомка — это целое число, содержащее код возврата и некоторую другую информацию о том, как завершился процесс.
\begin{itemize}
\item WIFEXITED() - возвращает ненулевое значение, если потомок завершится посредством возврата из функции main() или через вызов exit().
\item WEXITSTATUS() - возвращает код возврата завершившегося процесса. Этот макрос вызывается в том случае, если WIFEXITED() вернул ненулевое значение.
\item WIFSIGNALED() - возвращает ненулевое значение, если процесс был завершен
посредством получения сигнала. 
\item WTERMSIG(), WCOREDUMP(), WIFSTOPPED(), WSTOPSIG() и WCONTINUED() - относятся к сигналам (будут рассмотрены в следующей лекции).
\end{itemize}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic42.png}
\end{figure}
\end{frame}

\begin{frame}
\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{images/lec07-pic14.png}
\end{figure}
\end{frame}

\begin{frame}{Ожидание определенного процесса}
Если вам известен pid процесса, завершения которого вы ждете, можно использовать системный вызов waitpid():
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/lec07-pic15.png}
\end{figure}
Параметр pid точно определяет:
\begin{itemize}
\item $< -1$ - ожидание любого дочернего процесса, чей ID группы процессов равен
абсолютному значению этой величины;
\item $–1$ - ожидание любого дочернего процесса; поведение аналогично wait();
\item $0$ - ожидание любого дочернего процесса, принадлежащего той же группе процессов, что и вызывающий;
\item $> 0$ - ожидание любого дочернего процесса, чей pid в точности равен указанной
величине.
\end{itemize}
\end{frame}

\section{Пользователи и группы}
\begin{frame}
Существует четыре пользовательских идентификатора, ассоциированных с процессом: \begin{itemize}
\item \textit{Реальный идентификатор пользователя} - это uid пользователя, который изначально запустил процесс.
\item \textit{Действительный идентификатор пользователя} - это идентификатор, под которым в настоящий момент выполняется процесс. 
\item \textit{Сохраненным идентификатором пользователя} называется изначальный действительный пользовательский идентификатор. 
\end{itemize}
\end{frame}

\section{Демоны}
\begin{frame}{Демон}
\begin{block}{Демон}
процесс, который запущен в фоновом режиме и не привязан ни к какому управляющему терминалу.
\end{block}
Демоны обычно запускаются во время загрузки с правами root или другими специфическими пользовательскими правами (например, apache или postfix) и выполняют задачи системного уровня. 
\begin{itemize}
\item демон должен запускаться как потомок процесса init;
\item демон не должен быть связан с терминалом.
\end{itemize}
\end{frame}

\begin{frame}
\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/lec07-pic16.png}
\end{figure}
\end{frame}

\end{document}