\documentclass{beamer}
\mode<presentation>
\usetheme{CambridgeUS}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{sansmathaccent}

\usepackage{verbatim}
\usepackage{alltt}

\pdfmapfile{+sansmathaccent.map}
\title[Межпроцессное взаимодействие]{Обзор методов межпроцессного взаимодействия в Linux}
\author{Наумов Д.А., доц. каф. КТ}
\date[26.11.2019] {Операционные системы и системное программное обеспечение, 2019}

\begin{document}

%ТИТУЛЬНЫЙ СЛАЙД
\begin{frame}
  \titlepage
\end{frame}
  
%СОДЕРЖАНИЕ ЛЕКЦИИ
\begin{frame}
  \frametitle{Содержание лекции}
  \tableofcontents  
\end{frame}

\section{Обзор методов межпроцессного взаимодействия в Linux}

\subsection{Общие сведения о межпроцессном взаимодействии в Linux}

\begin{frame}
В основе межпроцессного взаимодействия (IPC, InterProcess Communication) лежит обмен данными между работающими процессами. 

Межпроцессное взаимодействие в Linux можно классифицировать по трем критериям:
\begin{itemize}
\item По широте охвата взаимодействие бывает локальным и удаленным. Локальное
взаимодействие подразделяется на родственное и неродственное.
\item По направлению передачи данных межпроцессное взаимодействие бывает однонаправленным и двунаправленным.
\item По характеру доступа взаимодействие бывает открытым и закрытым.
\end{itemize}
\begin{block}{Закрытое взаимодействие}
взаимодействие осуществляется только между двумя процессами.
\end{block}
\begin{block}{Открытое взаимодействие}
какой-нибудь другой процесс может присоединиться к обмену данными.
\end{block}
\end{frame}

\begin{frame}
\begin{block}{Локальное взаимодействие}
отвечает за обмен данными между процессами, которые работают в одной Linux-системе. Если обмен данными осуществляется между родительским и дочерним процессами, то такое взаимодействие называется родственным.
\end{block}
\begin{block}{Удаленное взаимодействие}
это обмен данными между двумя процессами, которые работают в разных системах. 
\end{block}
\begin{block}{Однонаправленное межпроцессное взаимодействие }
характеризуется тем, что один процесс является отправителем данных, другой — приемником этих данных.
\end{block}
\begin{block}{Двунаправленное взаимодействие}
позволяет процессам общаться на равных, но в этом случае процессы должны "договориться" об очередности и синхронизации приема и передачи информации.
\end{block}
\end{frame}

\begin{frame}
Существование различных способов межпроцессного взаимодействия обусловлено тем, что при их реализации возникают две проблемы:
\begin{enumerate}
\item \textit{Проблема синхронизации}. Процессы работают независимо друг от друга, в ходе обмена данными между процессами должна учитываться эта "независимость".
\item \textit{Проблема безопасности}. Если один процесс направляет данные другому процессу, то возникает опасность того, что потенциальный злоумышленник может перехватить эти данные. Проблема усложняется еще и тем, что злоумышленник может "подсунуть" процессу-приемнику собственные данные, если последние не защищены. Чем шире зона охвата межпроцессного взаимодействия, тем более уязвимым (с точки зрения безопасности) оно является.
\end{enumerate}
\end{frame}

\subsection{Локальные методы межпроцессного взаимодействия}

\begin{frame}
\begin{itemize}
\item Простейший способ межпроцессного взаимодействия — локальное родственное двунаправленное закрытое взаимодействие родителя и потомка.
\item Родительский процесс может передавать дочернему некоторые данные посредством аргументов через
одну из функций семейства exec(). 
\item В свою очередь дочерний процесс при нормальном завершении сообщает родителю свой код возврата. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример: kinsfolk-child1.c}
\begin{alltt}
\$ gcc -o kinsfolk-child1 kinsfolk-child1.c
\$ ./kinsfolk-child1 2007
\$ echo \$?
0
\$ ./kinsfolk-child1 2008
\$ echo \$?
1
\$ ./kinsfolk-child1 2300
\$ echo \$?
0
\$ ./kinsfolk-child1 2400
\$ echo \$?
1
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Пример: kinsfolk-parent.c}
\begin{alltt}
\$ gcc -o kinsfolk-parent1 kinsfolk-parent1.c
\$ ./kinsfolk-parent1 2000
2000: leap year
\$ ./kinsfolk-parent1 2007
2007: not leap year
\end{alltt}
\end{frame}

\subsection{Удаленное межпроцессное взаимодействие}

\begin{frame}{Удаленное межпроцессное взаимодействие}
\begin{block}{Сокет}
комплексное понятие, которое условно можно назвать "точкой соединения процессов"
\end{block}
\begin{itemize}
\item Unix-сокеты для локального взаимодействия процессов;
\item Интернет-сокеты для удаленного взаимодействия процессов.
\end{itemize}
В программах сокеты фигурируют в виде файловых дескрипторов, над которыми (во многих случаях) можно осуществлять обычные операции чтения-записи (read(), write() и т. д.). 
\begin{itemize}
\item При взаимодействии посредством сокетов процессы рассматриваются по схеме "клиент — сервер".
\item Процесс-сервер устанавливает "правила общения" и предлагает всем желающим межпроцессное взаимодействие. 
\end{itemize}
\end{frame}

\section{Сигналы}

\begin{frame}{Понятие сигнала}
\begin{block}{Cигнал}
сообщение, которое один процесс-отправитель посылает другому процессу или самому себе.
\end{block}
\begin{itemize}
\item В распоряжении процессов находится стандартный набор сигналов, заранее определенных ядром Linux.
\item Каждый сигнал имеет свой уникальный номер, а также символическую константу, соответствующую этому номеру. 
\end{itemize}
Процесс-получатель может отреагировать на сигнал одним из следующих трех способов:
\begin{itemize}
\item \textbf{Принятие сигнала}. Обычно это приводит к немедленному завершению процесса.
\item \textbf{Игнорирование сигнала}. Процесс может установить для себя политику игнорирования определенных сигналов. 
\item \textbf{Перехватывание и обработка сигнала}. Процесс может задать собственное поведение в отношении конкретного сигнала.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\begin{alltt}
\$ kill -s SIGNAL PID
\end{alltt}
Здесь SIGNAL — это символическая константа посылаемого сигнала, PID — идентификатор процесса-получателя сигнала. 
\begin{alltt}
\$ yes > /dev/null &
[1] 5852
\$ ps
PID TTY TIME CMD
5481 pts/2 00:00:00 bash
5852 pts/2 00:00:04 yes
5853 pts/2 00:00:00 ps
\$ kill -s SIGINT 5852
\$ ps
PID TTY TIME CMD
5481 pts/2 00:00:00 bash
5854 pts/2 00:00:00 ps
[1]+ Interrupt yes >/dev/null
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Отправка сигнала kill()}
Для отправки сигнала предусмотрен системный вызов kill(), который объявлен в заголовочном файле signal.h следующим образом:
\begin{alltt}
int kill (pid_t PID, int SIGNAL);
\end{alltt}
Этот системный вызов посылает процессу с идентификатором PID сигнал SIGNAL.
Возвращаемое значение — 0 (при успешном завершении) или –1 (в случае ошибки).
\begin{alltt}
Программа kill1.c
\end{alltt}
Если в аргументе PID системного вызова kill() указать текущий идентификатор, то процесс пошлет сигнал сам себе. 
\begin{alltt}
Программа kill2.c
\end{alltt}
\end{frame}

\begin{frame}[fragile]{ОБработка сигнала sigaction()}
Системный вызов sigaction() позволяет задавать поведение процесса по отношению к конкретным сигналам:
\begin{alltt}
int sigaction (int SIGNAL, const struct sigaction * ACTION, 
  struct sigaction * OLDACTION);
\end{alltt}
Данный системный вызов устанавливает политику реагирования процесса на сигнал SIGNAL. Политика определяется указателем ACTION на структуру типа sigaction. При удачном завершении функции по адресу OLDACTION заносится прежняя политика в отношении сигнала. 

Структура sigaction содержит различные поля:
\begin{itemize}
\item sa\_handler — адрес функции-обработчика сигнала; 
\item sa\_flags — набор флагов. Для простой обработки сигнала достаточно обнулить это поле;
\item sa\_mask — маска сигналов. Список сигналов, которые будут заблокированы во время работы функции-обработчика. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример sigaction1.c}
Системный вызов sigaction() позволяет задавать поведение процесса по отношению к конкретным сигналам:
\begin{alltt}
\$ gcc -o sigaction1 sigaction1.c
\$ ./sigaction1
signal...
signal...
signal...
signal...
\end{alltt}
Обратите внимание, что каждый раз при нажатии клавиш Ctrl+C процесс реагирует мгновенно. 
При использовании сигналов всегда следует помнить, что на момент получения сигнала программа может выполнять что-то важное.
\begin{alltt}
\$ ps -e | grep sigaction1
4883 pts/1 00:44:27 sigaction1
\$ kill 4883
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Сигналы и многозадачность}
Если во время выполнения функции-обработчика процесс получает еще один сигнал, программа может начать вести себя неадекватно.
\begin{itemize}
\item включить в обработчик сигнала минимальное число инструкций. Лучше, если это будет
одна инструкция, которая просто устанавливает флаг, регистрирующий получение
сигнала. 
\item программа может при необходимости проверять значение этого флага и реагировать соответствующим образом.
\item применяется специальный тип данных sig\_atomic\_t - обычное целое число, но ядро Linux гарантирует, что математические операции над таким числом являются атомарными и не могут быть прерваны.
\end{itemize}
Пример 1: sigaction2.c

Пример 2: kinsfolk-child2.c, kinsfolk-parent2.c
\end{frame}

\section{Использование общей памяти}

\begin{frame}[fragile]{Использование общей памяти}
Реализация межпроцессного взаимодействия посредством совместно используемой памяти:
\begin{enumerate}
\item один из процессов выделяет некоторый объем памяти, который называется сегментом. К общему сегменту памяти привязаны два числа:
\begin{itemize}
\item Идентификатор сегмента — служит для доступа к сегменту внутри процесса.
\item Ключ сегмента — идентифицирует сегмент для других процессов. Ключ может
быть выделен автоматически во время создания сегмента. Процессы могут также заранее договориться о применении определенного статического ключа.
\end{itemize}
\item после выделения совместно используемого сегмента другие процессы могут задействовать его. 
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Выделение общей памяти}
Выделение общей памяти осуществляется при помощи системного вызова shmget(), который объявлен в заголовочном файле sys/shm.h следующим образом:
\begin{alltt}
int shmget (key_t KEY, size_t SIZE, int FLAGS);
\end{alltt}
\begin{itemize}
\item KEY — это ключ сегмента. Если взаимодействующие программы не договорились заранее о применении статического ключа, то в данном поле можно указать константу IPC\_PRIVATE, которая инициирует динамическое выделение ключа.
\item SIZE — размер сегмента. Здесь следует учитывать, что данный аргумент является запрашиваемым числом байтов для сегмента. Реально выделенное число байтов может отличаться от SIZE.
\item Аргумент FLAGS определяет права доступа к совместно используемому сегменту, а также дополнительные флаги.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Активизация совместного доступа}
Процесс может получить доступ к созданному сегменту двумя способами:
\begin{itemize}
\item Использовать идентификатор сегмента, полученный от другого процесса.
\item Вызвать shmget(), применяя для этого заранее известный ключ.
\end{itemize}
Для работы с общим сегментом памяти нужно, чтобы каждый из взаимодействующих процессов обратился к системному вызову shmat()
\begin{alltt}
void * shmat (int ID, void * ADDRESS, int FLAGS);
\end{alltt}
Данный системный вызов возвращает адрес совместно используемого сегмента памяти. 
\begin{itemize}
\item ID — это идентификатор сегмента. 
\item ADDRESS - адрес, по которому будет доступен общий сегмент памяти. 
\item FLAGS - дополнительные флаги.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Отключение совместного доступа}
Системный вызов shmdt() вызывается в каждом процессе после того, как тот закончил работу с общей памятью. 
\begin{alltt}
int shmdt (void * ADDRESS);
\end{alltt}
\begin{itemize}
\item ADDRESS — это адрес совместно используемой памяти, который возвращает shmat() при подключении сегмента.
\end{itemize}
Системный вызов shmctl() позволяет осуществлять различные операции над общим сегментом памяти.
\begin{alltt}
int shmctl (int ID, int COMMAND, struct shmid_ds * DESC);
\end{alltt}
\begin{itemize}
\item ID — это идентификатор сегмента. 
\item COMMAND — команда, которую требуется выполнить в отношении сегмента общей памяти с идентификатором ID. Часто употребляются две команды: IPC\_STAT (получить данные о сегменте) и IPC\_RMID (удалить сегмент).
\item DESC — указатель на структуру, в которую (для команды IPC\_STAT) заносятся данные о сегменте. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример}
shm1-owner.c
\begin{itemize}
\item Программа создает общий сегмент с использованием "динамического ключа" (IPC\_PRIVATE). 
\item После успешного создания и подключения сегмента программа выводит на экран его идентификатор, заносит в сегмент данные и останавливается до тех пор, пока пользователь не нажмет клавишу Enter. 
\item Эта задержка позволяет другому процессу подключить общий сегмент памяти и прочитать оттуда данные.
\end{itemize}
shm1-user.c
\begin{itemize}
\item Поскольку процессы "не договорились" заранее о выделении общего ключа для сегмента памяти, то единственным адекватным способом взаимодействия будет непосредственная передача программе-клиенту идентификатора сегмента через аргумент.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример}
В первом окне запускаем процесс-сервер:
\begin{alltt}
\$ gcc -o shm1-owner shm1-owner.c
\$ ./shm1-owner
ID: 31391750
Press <Enter> to exit...
\end{alltt}
Теперь, не нажимая клавиши <Enter>, переходим в другое терминальное окно и запускаем процесс-клиент:
\begin{alltt}
\$ gcc -o shm1-user shm1-user.c
\$ ./shm1-user 31391750
Message: Hello World!
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Пример}
Наберите в клиентском окне команду ipcs -m. Эта команда выводит на экран список совместно используемых сегментов памяти с их ключами и идентификаторами. 
\begin{alltt}
\$ ipcs -m
------ Shared Memory Segments --------
key shmid owner perms bytes nattch status
0x00005d8b 13565953 root 777 316 1
0x00000000 13795330 nn 600 393216 2 dest
0x00000000 13828099 nn 600 393216 2 dest
0x00000000 29589508 nn 666 112320 1 dest
0x00000000 14811141 nn 777 393216 2 dest
0x00000000 31391750 nn 600 4096 1
\end{alltt}
\end{frame}

\begin{frame}[fragile]{Пример}
Теперь нажмите клавишу Enter в исходном терминале и вызовите ipcs -m еще раз:
\begin{alltt}
\$ ipcs -m
------ Shared Memory Segments --------
key shmid owner perms bytes nattch status
0x00005d8b 13565953 root 777 316 1
0x00000000 13795330 nn 600 393216 2 dest
0x00000000 13828099 nn 600 393216 2 dest
0x00000000 29589508 nn 666 112320 1 dest
0x00000000 14811141 nn 777 393216 2 dest
\end{alltt}
\end{frame}

%\section{Использование общих файлов}
%\section{Каналы}
%\section{Именованные каналы FIFO}
%\section{Сокеты}

\end{document} 
