\documentclass[xcolor=table]{beamer}
\mode<presentation>
\usetheme{CambridgeUS}
\usepackage[english, russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{sansmathaccent}
\usepackage{alltt}
\usepackage[table]{xcolor}
\linespread{0.8}
\usepackage{minted}
\usepackage{setspace}

\pdfmapfile{+sansmathaccent.map}
\title[Язык C]{Основы программирования на С}
\author{Наумов Д.А., доц. каф. КТ}
\date[10.09.2020] {Операционные системы и системное программное обеспечение, 2020}

\begin{document}

%ТИТУЛЬНЫЙ СЛАЙД
\begin{frame}
  \titlepage
\end{frame}
  
%СОДЕРЖАНИЕ ЛЕКЦИИ
\begin{frame}
  \frametitle{Содержание лекции}
  \tableofcontents  
\end{frame}

\section{Основные операторы языка}

\begin{frame}{Операторы языка C}
К основным операторам языка C относятся: 
\begin{itemize}
\item Операторы-выражения;
\item Описания переменных;
\item Управляющие операторы.
\end{itemize}

Управляющие операторы задают порядок, в котором выполняются вычислительные операции программы. К управляющим операторам относятся:
\begin{itemize}
\item Условный оператор;
\item Оператор выбора;
\item Операторы цикла;
\item Операторы безусловного перехода.
\end{itemize}
\end{frame} 

\begin{frame}{Операторы-выражения}
Любое выражение, которое заканчивается точкой с запятой, является оператором.

Например:
\begin{alltt}
    func();    /* вызов функции */ 
    
    a = b + c; /* оператор присваивания */
    
    b + f();   /* правильный, но "странный" оператор */
    
     ;         /* пустой оператор */
\end{alltt}
В языке C точка с запятой является элементом оператора и его завершающей частью, а не разделителем операторов, как в языке Pascal.
\end{frame}

\begin{frame}[fragile]{Блоки}
    % !! ОНО НЕ УМЕЩАЕТСЯ !!
    % UPD я это утрамбовала на один слайд, но какой ценой
    Блок - это последовательность операторов, заключенных в фигурные скобки и рассматривающихся как одна программная единица. Операторы, составляющие блок, логически связаны друг с другом. Иногда блок называют составным оператором. Блок всегда начинается открывающейся фигурной скобкой \{ и заканчивается закрывающейся \}. Чаще всего блок используется как составная часть какого-либо оператора, выполняющего действие над группой операторов, например \texttt{if} или \texttt{for}. Однако блок можно поставить в любом месте, где может находиться оператор, как это показано в следующем примере:
    \begin{minted}{c}
        #include <stdio.h>
        int main(){
            int i;
            { /* блок операторов */
                i = 120;
                printf("\%d", i);
            }
            return 0;
        }   
    \end{minted}    
\end{frame}

\section{Объявления переменных}

\begin{frame}{Объявления переменных}
    Все переменные необходимо объявить до их использования. В объявлении указываются тип и список из одной или нескольких переменных этого типа:
    \begin{alltt}
        int lower, upper, step;
        
        char c;
    \end{alltt}
    
    Переменные можно инициализировать прямо в объявлениях. Если после имени поставить знак равенства и выражение, то значение этого выражения будет присвоено переменной при ее создании:
    \begin{alltt}
        int i = 0;
        
        int limit = MAXLINE + 1;
    \end{alltt}
    
    Объявление переменных может быть расположено в трех местах: внутри функции, в определении параметров функции и вне всех функций. Это - места объявлений соответственно локальных, формальных параметров функций и глобальных переменных.
\end{frame}

\begin{frame}{Области видимости переменных}
    Чаще всего говорят о локальных и глобальных идентификаторах. Однако в языке C предусмотрено более тонкое подразделение этих двух широких категорий. Стандарт C определяет четыре типа областей видимости идентификаторов
    % !! ОНО НЕ УМЕЩАЕТСЯ !!
    {\rowcolors{1}{red!15!}{white!100!}
    {\small
        \begin{center}
            \begin{tabular}{ |p{4cm}|p{7cm}| } 
                \hline
                \rowcolor{red!60!}
                Тип области видимости & Область видимости \\ \hline
                 % строка 2 столбец 1
                 Область действия - файл (имя, объявленное вне всех блоков, можно использовать в транслируемом файле, содержащем это объявление)
                 % строка 2 столбец 2
                 &
                 Начинается в начале файла и кончается в конце файла. Такую область видимости имеют только идентификаторы, объявленные вне функции. Эти идентификаторы видимы в любом месте файла. Переменные с этой областью видимости являются глобальными
                 \\ \hline
                Область действия - блок &
                Начинается открывающейся фигурной скобкой блока и кончается с его закрытием скобкой. Эту область видимости имеют также параметры функции. Переменные, имеющие такую область видимости, являются локальными в своем блоке\\ \hline
                Область действия - прототип функции &
                Идентификаторы, объявленные в прототипе функции, видимы внутри прототипа \\ \hline
                Область действия - функция &
                Начинается открывающейся фигурной скобкой функции и кончается с ее закрытием скобкой. Такую область видимости имеют только метки. Метка используется оператором \texttt{goto} и должна находиться в той же функции \\ \hline
            \end{tabular}
        \end{center}
    }}
 
\end{frame}

\begin{frame}{Квалификатор типа}
    В языке C определяются квалификаторы типа, указывающие на доступность и модифицируемость переменной. Стандарт C89 опеределяет два квалификатора: \texttt{const} и \texttt{volatile}.
\end{frame}

\begin{frame}{Квалификатор \texttt{const}}
    Переменная, к которой в объявлении применен квалификатор \texttt{const}, не может менять свое значение. Ее можно только инициализировать, то есть присвоить ей значение в начале выполнения программы. Компилятор может поместить переменную этого типа в постоянное запоминающее устройство. Например, в объявлении 
    \begin{alltt}
        const int a = 10;
    \end{alltt}
    создается переменная с именем \texttt{a}, причем ей присваивается начальное значение 10, которое в дальнейшем в программе изменить никак нельзя. 
    
    Квалификатор \texttt{const}  часто используется для того, чтобы предотвратить изменение функцией объекта, на который указывает аргумент функции. Без него при передаче в функцию указателя эта функция может изменить объект, на который он указывает. Однако если в объявлении параметра-указателя применен квалификатор \texttt{const}, функция не сможет изменить этот объект. Например:
    \begin{alltt}
        size\_t strlen(const char *str);
    \end{alltt}
\end{frame}

\begin{frame}{Квалификатор \texttt{volatile}}
    Квалификатор \texttt{volatile} указывает компилятору на то, что значение переменной может измениться независимо от программы, т.е. вследствие воздействия еще чего-либо, не являющегося оператором программы.
    
    Например, адрес глобальной переменной можно передать в подпрограмму операционной системы, следящей за временем, и тогда эта переменная будет содержать системное время. В этом случае значение переменной будет изменяться без участия какого-либо оператора программы.
    
    Знание таких подробностей важно потому, что большинство компиляторов C автоматически оптимизируют некоторые выражения, предполагая при этом неизменность переменной, если она не встречается в левой части оператора присваивания. В этом случае при очередной ссылке на переменную может использоваться ее предыдущее значение. Некоторые компиляторы изменяют порядок вычисления в выражениях, что может привести к ошибке, если в выражении присутствует переменная, вычисляемая вне программы.
    
    Квалификатор \texttt{volatile} предотвращает такие изменения программы.
\end{frame}

\begin{frame}{Спецификаторы класса памяти}
    Стандарт C поддерживает четыре спецификатора класса памяти:
    \begin{alltt}
        extern
        
        static
        
        register
        
        auto
    \end{alltt}
    
    эти спецификаторы сообщают компилятору, как он должен разместить соответствующие переменные в памяти. Общая форма объявления переменных при этом такова:
    \begin{alltt}
        спецификатор\_класса\_памяти тип имя\_переменной;
    \end{alltt}
    
    Спецификатор класса памяти в объявлении всегда должен стоять первым.
\end{frame}

\begin{frame}{Спецификатор \texttt{extern}}
    Спецификатор \texttt{extern} указывает на то, что к объекту применяется внешнее связывание, именно поэтому он будет доступен во всей программе.
    
    Далее нам понадобятся чрезвычайно важные понятия объявления и описания.
    
    Объявление (декларация) объявляет имя и тип объекта. Описание (определение) выделяет для объекта участок памяти, где он будет находиться. Один и тот же объект может быть объявлен неоднократно в разных местах, но описан он может быть только один раз.
    
    Спецификатор \texttt{extern} играет большую роль в программах, состоящих из многих файлов. В языке C программа может быть записана в нескольких файлах, которые компилируются раздельно, а затем компонуются в одно целое. В этом случае необходимо как-то сообщить всем файлам о глобальных переменных программы. Самый лучший (и наиболее переносимый) способ сделать это - определить (описать) все глобальные переменные в одном файле и объявить их спецификатором \texttt{extern} в остальных файлах, как показано в следующем примере.
\end{frame}

\begin{frame}[fragile]{Спецификатор \texttt{extern}}
\begin{tabular}{p{5cm} p{5cm}}
    \begin{minted}{c}
    /* файл 1*/
    int x, y;
    char ch;
    int main(void){
        /* ... */
    }
    void func1(void){
        x = 123;
    }
    \end{minted}
     &
    \begin{minted}{c}
    /* файл 2 */
    extern int x, y;
    extern char ch;
    void func22(void){
        x = y / 10;
    }
    void func23(void){
        y = 10;
    }
    \end{minted}
\end{tabular}
    
    % !! НЕ ВЛЕЗАЕТ !!
    Во втором файле спецификатор \texttt{extern} сообщает компилятору, что переменные \texttt{x, y, ch} определены в других файлах. Таким образом, компилятор узнает имена и типы переменных, размещенных в другом месте, и может отдельно компилировать второй файл, ничего не зная о первом. При компоновке этих двух модулей все ссылки на глобальные переменные будут разрешены. На практике программисты обычно включают объявления \texttt{extern} в заголовочные файлы, которые просто подключаются к каждому файлу исходного текста программы. Это более легкий путь, который к тому же приводит к меньшему количеству ошибок, чем повторение этих объявлений вручную в каждом файле.
\end{frame}

\begin{frame}{Спецификатор \texttt{static}}
    Переменные, объявленные со спецификатором \texttt{static}, хранятся постоянно внутри своей функции или файла. В отличие от глобальных переменных они невидимы за пределами своей функции или файла, но они сохраняют свое значение между вызовами. Эта особенность делает их полезными в общих и библиотечных функциях, которые будут использоваться другими программистами. Спецификатор \texttt{static} воздействует на локальные и глобальные переменные по-разному.
    
    Статические локальные переменные - это локальные переменные, сохраняющие свое значение между вызовами функции. 
    
    Спецификатор \texttt{static} в объявлении глобальной переменной заставляет компилятор создать глобальную переменную, видимую только в том файле, в котором она объявлена.
\end{frame}

\begin{frame}{Спецификатор \texttt{register}}
    Первоначально спецификатор класса памяти \texttt{register} применялся только к переменным типа \texttt{int, char} и для указателей. Однако стандарт C расширил использование спецификатора \texttt{register}, теперь он может применяться к переменным любых типов.
    
    В первых версиях компиляторов C спецификатор \texttt{register} сообщал компилятору, что переменная должна храниться в регистре процессора, а не в оперативной памяти, как все остальные переменные. Это приводит к тому, что операции с переменной \texttt{register} осуществляются намного быстрее, чем с обычными переменными, потому что такая переменная уже находится в процессоре и не нужно тратить время на выборку ее значения из оперативной памяти (и на запись в память).
    
    В настоящее время определение спецификатора \texttt{register} существенно расширено. Стандарты C89 и C99 попросту декларируют "доступ к объекту так быстро, как только возможно". Практически при этом символьные и целые переменные по-прежнему размещаются в регистрах процессора. Конечно, большие объекты (например, массивы) не могут поместиться в регистры процессора, однако компилятор получает указание "позаботиться" о быстродействии операций с ними. в зависимости от конкретной реализации компилятора и операционной системы переменные \texttt{register} обрабатываются по-разному.
\end{frame}

\section{Условный оператор}

\begin{frame}{Условный оператор \texttt{if}}
    Оператор \texttt{if} выполняет один из двух операторов в зависимости от значения некоторого условия.
    \begin{alltt}
        if (выражение)
            
        \qquad оператор1
        
        else
        
        \qquad оператор2
    \end{alltt}
    
    Часть, начинающаяся со слова \texttt{else}, необязательна.
    
    В начале вычисляется выражение; если оно истинно (т.е. имеет ненулевое значение), то выполняется оператор1. Если оно ложно (т.е. имеет нулевое значение) и присутствует блок \texttt{else}, то выполняется оператор2.
    \begin{alltt}
        if (a < b)
        
        \qquad z = a;
        
        else
        
        \qquad z = b;
    \end{alltt}
    \textbf{Точки с запятой - это часть операторов-выражений!}
\end{frame}

\section{Оператор выбора}

\begin{frame}{Оператор выбора \texttt{switch}}
    Оператор \texttt{switch} используется для выбора одного из нескольких вариантов действий в зависимости от того, с какой из набора целочисленных констант совпадает значение некоторого выражения.
    \begin{alltt}
        switch (выражение)\{
        
        \qquad case константное-выражение: операторы
        
        \qquad case константное-выражение: операторы
        
        \qquad default: операторы
        
        \}
    \end{alltt}
    
    Блок \texttt{default} выполняется в том случае, если не найдено ни одного соответсвия в блоках \texttt{case}.
    
    Отличие от оператора \texttt{case} в языке Pascal состоит в том, что выражения \texttt{case} являются не отдельными ветвями алгоритма, а всего лишь метками, поэтому после перехода на одну из меток \texttt{case} будут выполнены все операторы после этой метки и до конца оператора \texttt{switch}, вне зависимости от наличия остальных меток \texttt{case}. Чтобы это предотвратить, в месте завершения ветви алгоритма нужно поставить оператор \texttt{break}.
\end{frame}

\section{Операторы циклов}

\begin{frame}{Оператор цикла \texttt{while}}
    Цикл с предусловием \texttt{while} имеет формат:
    \begin{alltt}
        while (выражение)
            
        \qquad оператор
    \end{alltt}
    
    Выражение представляет собой условие продолжения цикла, которое вычисляется перед началом каждой итерации. Если выражение истинно, то выполняется очередная итерация цикла. Если выражение ложно, то цикл завершается.
    
    Частный случай - бесконечный цикл:
    \begin{alltt}
        while (1)
            
        \qquad оператор
    \end{alltt}
\end{frame}

\begin{frame}{Оператор цикла \texttt{do-while}}
    Цикл \texttt{do-while} является циклом с постусловием, т.е. в нем условие проверяется после выполнения итерации цикла. Цикл \texttt{do-while} имеет формат:
    \begin{alltt}
        do
            
        \qquad оператор
        
        while (выражение);
    \end{alltt}
    Здесь сначала выполняется оператор, затем вычисляется выражение. Если оно истинно (не равно нулю), то снова выполняется оператор, и т.д. Как только выражение становится ложным, выполнение цикла прекращается.
    
    За исключением способа проверки выражения, цикл \texttt{do-while} аналогичен оператору \texttt{repeat-until} в языке Pascal.
\end{frame}

\begin{frame}{Оператор цикла \texttt{for}}
    Цикл \texttt{for} имеет следующий формат:
    \begin{alltt}
        for (выраж1; выраж2; выраж3)
            
        \qquad оператор
    \end{alltt}
    где выраж1 - инициализирующее выражение.Вычисляется один раз перед выполнением первой итерации цикла. Как правило содержит операции присваивания. Может содержать объявления переменных, которые будут существовать только в пределах цикла (в стандарте C99).
    
    выраж2 - условие продолжения цикла. Вычисляется перед каждой итерацией цикла. Если выраж2 истинно, то выполняется очередная итерация, если ложно - то цикл завершается.
    
    выраж3 - модифицирующее выражение. Вычисляется после каждой итерации цикла. Как правило содержит операции инкрементирования параметров цикла.
    
    Любое из выражений может отсутствовать.
\end{frame}

\begin{frame}{Оператор цикла \texttt{for}}
    Наиболее распространенный вариант цикла \texttt{for} (соответствующий циклу \texttt{for} в языке Pascal) имеет вид:
    \begin{alltt}
        for (i = 0; i <= n; i++)
            
        \qquad оператор
    \end{alltt}
    В  языке C Допускаются и более сложные конструкции, например:
    \begin{alltt}
        for (int i = 0, int j = 3; i + j < 100; i++, j+=2)
            
        \qquad оператор
    \end{alltt}
    Если все три выражения в операторе \texttt{for} отсутствуют, то такой оператор представляет собой бесконечный цикл:
    \begin{alltt}
        for (;;)
            
        \qquad оператор
    \end{alltt}
\end{frame}

\section{Операторы перехода}

\begin{frame}{Метки. Оператор \texttt{goto}}
    В языке C имеется оператор \texttt{goto} - бездонный источник потенциальных неприятностей - и метки для перехода с его помощью.
    
    В техническом плане \texttt{goto} никогда не бывает необходим, и на практике почти всегда легче обходиться без него.
    
    тем не менее, в некоторых ситуациях оператор \texttt{goto} может упростить программу. Например:
    \begin{alltt}
        for ( ... )
        
        \qquad for ( ... ) \{
                
        \qquad \qquad if (disaster)
                
        \qquad \qquad \qquad goto error;
            
            \}
    
    error:
    
    \qquad решить проблему
    \end{alltt}
    Метка для перехода имеет ту же форму, что и имя переменной. После нее ставится двоеточие. Ее можно поставить перед любым оператором в той же функции, в которой находится соответствующий \texttt{goto}. Область действия метки - вся функция.
\end{frame}

\begin{frame}{Операторы \texttt{break} и \texttt{continue}}
    Иногда бывает удобно выйти из цикла другим способом, отличным от проверки условия в его начале или в конце.
    
    \medskip
    Оператор \texttt{break} вызывает принудительный выход из циклов \texttt{for}, \texttt{while}, \texttt{do-while} - аналогично выходу из оператора \texttt{switch}.Выход выполняется из ближайшего (самого внутреннего) цикла или оператора \texttt{switch}.
    
    \medskip
    Оператор \texttt{continue} напоминает \texttt{break}, но используется реже: он передает управление на следующую итерацию ближайшего цикла \texttt{for}, \texttt{while}, \texttt{do-while}.В цикле \texttt{while} или \texttt{do-while} это означает немедленную проверку условия, тогда как в цикле \texttt{for} дополнительно выполняется инкрементирование.
\end{frame}

\begin{frame}{Оператор возврата из функции \texttt{return}}
    Оператор \texttt{return} выполняет выход из функции и задает ее значение. Если функция возвращает значение, оператор \texttt{return} имеет формат:
    \begin{alltt}
        return выражение;
    \end{alltt}
    В функциях типа \texttt{void} (не возвращающих значение) используется сокращенная форма:
    \begin{alltt}
        return;
    \end{alltt}
\end{frame}

\section{Функции ввода/вывода}

\begin{frame}{Функции ввода/вывода на консоль}
    В языке С нет специальных языковых конструкций для операций ввода/вывода данных. Операции ввода/вывода реализованы в виде библиотечных функций, для работы с которыми необходимо включить файл \texttt{<stdio.h>}.
    
    Далее рассматриваются консольные функции ввода/вывода, т.е. те, которые выполняют ввод с клавиатуры и вывод на экран в текстовом режиме. В действительности же эти функции работают со стандартным потоком ввода и стандартным потоком вывода. Более того, стандартный ввод и стандартный вывод могут быть перенаправлены на другие устройства.
    
    Рассматриваются:
    \begin{itemize}
        \item Чтение и запись символов;
        \item Чтение и запись строк;
        \item Форматный ввод/вывод на консоль (\texttt{printf()} и \texttt{scanf()})
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Чтение и запись символов}
    Простейшими функциями ввода/вывода являются функции \texttt{getchar()} и \texttt{putchar()}, предназначенные для ввода/вывода одиночных символов. Данные функции имеют следующие прототипы:
    \begin{alltt}
        int getchar(void);
        int putchar(int);
    \end{alltt}
    Функция \texttt{getchar()} при каждом ее вызове возвращает следующий символ из потока или \texttt{EOF} в случае конца файла.
    
    Функция \texttt{putchar()} помещает символ помещает символ в стандартный поток вывода, который по умолчанию соответствует экрану монитора. Функция \texttt{putchar()} возвращает выведенный символ или \texttt{EOF} в случае ошибки.
    
    Пример: программа, переводящая поступающие данные в нижний регистр:
    \begin{minted}{c}
        #include <stdio.h>
        int main(){
            int c;
            while ((c = getchar()) != EOF)
                putchar(tolower(c));
            return 0;
        }
    \end{minted}
\end{frame}

\begin{frame}{Чтение и запись строк}
    Функции \texttt{fgets()} и \texttt{fputs()} позволяют считывать и отображать строки символов. 
    
    Прототип функции \texttt{fgets()}:
    
    \begin{alltt}
    \textcolor{red}{
    \texttt{char *fgets(char *str, int count, FILE *stream);}
    }
    \end{alltt}
    
    Функция \texttt{fgets()} считывает до \texttt{count - 1} символов из входного потока \texttt{stream} и сохраняет их в \texttt{str}. В случае успеха возвращает указатель на строку, в случае ошибки - указатель на \texttt{NULL}.
    
    Прототип функции \texttt{fputs()}:
    
    \begin{alltt}
    \textcolor{red}{
    \texttt{int fputs(const char *str, FILE *stream );}
    }
    \end{alltt}
    
    Функция \texttt{fputs()} записывает строку \texttt{str} в поток вывода \texttt{stream}. В случае успеха функция возвращает неотрицательное значение, в случае ошибки - \texttt{EOF}.
\end{frame}

\begin{frame}{Форматный ввод/вывод на консоль}
    Функции \texttt{printf()} и \texttt{scanf()} выполняют форматный ввод и вывод, то есть они могут читать и писать данные в разных форматах.
    
    Данные на консоль выводит \texttt{printf()}.
    
    \medskip
    А ее ``дополнение`` , функция \texttt{scanf()}, считывает данные с клавиатуры.
    
    \medskip
    Обе функции могут работать с любым встроенным типом данных, а также с символьными строками, которые завершаются символом конца строки (\texttt{`\backslash 0 `}).
\end{frame}

\begin{frame}{Функция \texttt{printf()}}
    Прототип функции \texttt{printf()}:
    
    \begin{alltt}
    \textcolor{red}{
    int printf(const char *управляющая\_строка, ...);
    }
    \end{alltt}
    
    Функция \texttt{printf()} возвращает число выведенных символов или отрицательное значение в случае ошибки.
    
    \texttt{Управляющая\_строка} состоит из элементов двух видов. Первый из них - это символы, которые предстоит вывести на экран; второй - это спецификаторы преобразования, которые определяют способ вывода стоящих за ними аргументов. Каждый такой спецификатор начинается со знака процента, за которым следует код формата. Аргументов должно быть ровно столько, сколько и спецификаторов, причем спецификаторы преобразования и аргументы должны попарно соответствовать друг другу в направлении слева направо. Например, в результате такого вызова \texttt{printf()}
    
    \begin{alltt}
    \textcolor{red}{
    printf("Мне нравится язык \%c \%s", 'C', "и к тому же очень сильно!");
    }
    \end{alltt}
    
    Будет выведено
    
    \begin{alltt}
    \textcolor{red}{
    Мне нравится язык С и к тому же очень сильно
    }
    \end{alltt}
    
    В этом примере первому спецификатору преобразования (\texttt{\%c}) соответствует символ \texttt{'C'}, а второму (\texttt{\%s}) - строка \texttt{"и к тому же очень сильно!"}.
\end{frame}

\begin{frame}{Спецификаторы преобразования для функции \texttt{printf()}}
    \newline
    {\rowcolors{1}{red!15!}{white!100!}
    \begin{tabular}{m{1cm}|m{10cm}}
        \rowcolor{red!60!}
        Код & Формат \\
        \%a & Шестнадцатеричное число в виде 0xh.hhhhp+d (C99) \\
        \%A & Шестнадцатеричное число в виде 0Xh.hhhhP+d (C99) \\
        \%c & Символ \\
        \%d & Десятичное целое со знаком \\
        \%i & Десятичное целое со знаком \\
        \%e & Экспоненциальное представление ("е" в нижнем регистре) \\
        \%E & Экспоненциальное представление ("Е" в верхнем регистре) \\
        \%f & Десятичное с плавающей точкой \\
        \%g & В зависимости от того, какой вывод будет короче, используется \%e или \%f \\
        \%G & В зависимости от того, какой вывод будет короче, используется \%E или \%F \\
        \%o & Восьмеричное без знака \\
    \end{tabular}
    }
\end{frame}

\begin{frame}{Спецификаторы преобразования для функции \texttt{printf()}}
    \newline
    {\rowcolors{1}{red!15!}{white!100!}
    \begin{tabular}{m{1cm}|m{10cm}}
        \rowcolor{red!60!}
        Код & Формат \\
        \%s & Строка символов \\
        \%u & Десятичное целое без знака\\
        \%x & Шестнадцатеричное без знака (буквы в нижнем регистре) \\
        \%X & Шестнадцатеричное без знака (буквы в верхнем регистре) \\
        \%p & Указатель \\
        \%n & Аргумент, соответствующий этому спецификатору, должен быть указателем на целочисленную переменную. Спецификатор позволяет сохранить в это переменной количество записанных символов (записанных до того места, в котором находится код \%n) \\
        \%\% & Знак \% \\
    \end{tabular}
    }
\end{frame}

\begin{frame}{Модификаторы формата функции \texttt{printf()}}
    Во многих спецификаторах преобразования можно указать модификаторы, которые слегка изменяют их значение. Например, можно указывать минимальную ширину поля, количество десятичных разрядов и выравнивание. Модификатор формата помещают между знаком процента и кодом формата. Здесь могут располагаться:
    \begin{itemize}
        \item Знак "минус", задающий выравнивание выводимого аргумента по левому краю отведенного поля вывода.
        \item Число, задающее минимальную ширину поля. Преобразованный аргумент выводится в поле, ширина которого не меньше, чем заданная. Если необходимо, поле дополняется пробелами слева или справа до указанной длины.
        \item Точка, отделяющая ширину поля от точности представления.
        \item Число (точность представления), задающее максимальное количество символов при выводе строки, или количество цифр в вещественном числе после десятичной точки, или минимальное количество цифр для целого числа.
        \item Буква \texttt{h}, если целое число следует вывести как короткое (\texttt{short}), или буква \texttt{l}, если как длинное (\texttt{long}).
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Пример. Модификаторы минимальное ширины поля}
\begin{minted}{c}
#include <stdio.h>
int main(){
    double item = 10.12304;
    printf("\%f\backslash n", item);
    printf("\%10f\backslash n", item);
    printf("\%012f\backslash n", item);
    return 0;
}
\end{minted}
    
    Вот что выводится при выполнении это программы:
\begin{alltt}
10.123040
 10.123040
00010.123040 
\end{alltt}
\end{frame}


\begin{frame}[fragile]{Пример. Выравнивание вывода}
\begin{minted}{c}
#include <stdio.h>
int main(){
    printf(".........................\backslash n");
    printf("по правому краю: \%8d\backslash n", 100);
    printf(" по левому краю: \%-8d\backslash n", 100);
    return 0;
}
\end{minted}
    
    Вот что выводится при выполнении это программы:
\begin{alltt}
.........................
по правому краю:      100
 по левому краю: 100
\end{alltt}
\end{frame}

\begin{frame}{Функция \texttt{scanf()}}
    Функция \texttt{scanf()} выполняет ввод с консоли. Она может читать данный всех встроенных типов и автоматически преобразовывать числа в соответствующий внутренний формат, \texttt{scanf()} во многом выглядит как обратная к \texttt{printf()}. Прототип функции \texttt{scanf()}:
    
    \begin{alltt}
    % \textcolor{red}{
    \texttt{int scanf(const char *управляющая\_строка, ...);}
    % }
    \end{alltt}
    
    Эта функция возвращает количество тех элементов данных, которым было успешно присвоено значение.
    
    В случае ошибки \texttt{scanf()} возвращает \texttt{EOF}, \texttt{управляющая\_строка} определяет преобразование считываемых значений при записи их в переменные, на которые указывают элементы списка аргументов. \textbf{Все аргументы функции \texttt{scanf()} должны быть указателями.}
    
    Управляющая строка состоит из символов трех видов:
    \begin{itemize}
        \item спецификаторов преобразования,
        \item разделителей,
        \item символов, не являющихся разделителями.
    \end{itemize}
    
    Разделитель в управляющей строке дает \texttt{scanf()} указание пропустить в потоке ввода один или несколько начальных разделителей. Разделителями являются пробелы, табуляции, вертикальные табуляции, подачи страниц и разделители строк.
    
    Если в управляющей строке находится символ, не являющийся разделителем, то функция \texttt{scanf()} прочитает символ из входного потока, проверит, совпадает ли прочитанный символ с указанным в управляющей строке, и в случае совпадения пропустит прочитанный символ.
\end{frame}

\begin{frame}{Спецификаторы преобразования для функции \texttt{scanf()}}
    \newline
    {\rowcolors{1}{red!15!}{white!100!}
    \begin{tabular}{m{1cm}|m{10cm}}
        \rowcolor{red!60!}
        Код & Формат \\
        \%a & Значение с плавающей точкой (С99) \\
        \%c & Одиночный символ\\
        \%d & Десятичное целое число \\
        \%i & Читает целое число как в десятичном, так и восьмеричном или шестнадцатеричном формате \\
        \%e & Число с плавающей точкой \\
        \%f & Число с плавающей точкой \\
        \%g & Число с плавающей точкой \\
        \%o & Восьмеричное число \\
    \end{tabular}
    }
\end{frame}

\begin{frame}{Спецификаторы преобразования для функции \texttt{scanf()}}
    \newline
    {\rowcolors{1}{red!15!}{white!100!}
    \begin{tabular}{m{1cm}|m{10cm}}
        \rowcolor{red!60!}
        Код & Формат \\
        \%s & Строка символов \\
        \%x & Шестнадцатеричное без знака (буквы в нижнем регистре) \\
        \%p & Указатель \\
        \%n & Принимает целое значение, равное количеству уже считанных символов \\
        \%u & Десятичное целое без знака \\
        \%[] & Набор сканируемых символов \\
        \%\% & Знак \% \\
    \end{tabular}
    }
\end{frame}

\begin{frame}[fragile]{Пример использования функции \texttt{scanf()}}
    Пусть необходимо вводить строки данных, в которых содержатся даты в следующем формате:
    
    \texttt{25 Dec 1988}
    
    Функция \texttt{scanf()} для этого случая будет выглядеть так:
    
\begin{alltt}
    int day, year;
    char month[20];
    scanf("\%d \%s \%d", &day, &month, &year);
\end{alltt}
    
    Считывать дату в формате \texttt{мм/дд/гг} из входного потока можно таким оператором:
\begin{alltt}
    int day, month, year;
    scanf("\%d/\%d/\%d", &month, &day, &year);
\end{alltt}
\end{frame}

\end{document}