\documentclass{beamer}
\mode<presentation>
\usetheme{CambridgeUS}
\usepackage[english, russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{sansmathaccent}
\usepackage{alltt}
\linespread{0.8}
\usepackage{minted}

%\pdfmapfile{+sansmathaccent.map}
\title[Язык C]{Функции и структура программы}
\author{Наумов Д.А., доц. каф. КТ}
\date[10.09.2020] {Операционные системы и системное программное обеспечение, 2020}

\begin{document}

%ТИТУЛЬНЫЙ СЛАЙД
\begin{frame}
  \titlepage
\end{frame}
  
%СОДЕРЖАНИЕ ЛЕКЦИИ
\begin{frame}
  \frametitle{Содержание лекции}
  \tableofcontents  
\end{frame}

\section{Функции}

\begin{frame}{Функции в языке С}
    Функции являются основным средством структуризации программы на языке С. Программа на языке С состоит из функций и объявлений переменных.
    
    \\
    Функции позволяют:
    \begin{itemize}
        \item Сделать структуру программы более понятной, путем разбиения программы на части, заключенные внутри функций. Хорошо написанные функции скрывают подробности своей работы от тех частей программы, которым их знать не положено, таким образом проясняя задачу в целом и облегчая процесс внесения исправлений и дополнений.
        \item Повысить производительность с помощью повторного использования разработанных ранее функций.
    \end{itemize}
\end{frame}

\begin{frame}{Функции и процедуры}
    В языке Pascal существовало два типа подпрограмм, отличающихся синтаксически: функции (возвращающие значение результата) и процедуры (не возвращающие значение).
    
    В языке С существует единственное понятие - функция. Процедуры (подпрограммы, не возвращающие значения) являются функциями особого вида, имеющими тип результата \textbf{\texttt{void}}.
\end{frame}


\begin{frame}{Функции в языке С}
    В языке С существуют понятия объявления (декларации) и определения функции.
    
    Объявление функции содержит только информацию о количестве и типе аргументов и типе возвращаемого значения и не содержит тела функции. Объявление функции заканчивается знаком ";". Объявление функции должно стоять в программе до ее первого вызова. 
    
    Необходимость использования объявлений функций в языке С вызвана тем, что язык разрабатывался исходя из требования разбора программы за один проход.
\end{frame}

\section{Объявление и определение функции}

\begin{frame}{Функции в языке С}
    Определение функции в языке С имеет формат:
    \begin{alltt}
        возвр\_тип имя\_функции(список параметров)
        
        \{
            
        \qquad тело функции    
        
        \}
    \end{alltt}
    
    Минимальная функция: \texttt{\textbf{ dummy() \{ \}}}
    
    В отличие от переменных, все параметры функций должны объявляться отдельно, причем для каждого из них надо указывать и тип, и имя:
    
    \begin{alltt}
        f(тип имя\_переменной1, тип имя\_переменной1, ..., тип
        
        имя\_переменнойN)
        \\ \\
        \begin{tabular}{p{5cm} p{6cm}}
            f(int i, int k, int j)  & /* правильно */ \\
            f(int i, k, float j) & 
            /* не правильно, у переменной k должен быть собственный спецификатор типа*/
        \end{tabular}
    \end{alltt}

\end{frame}

\begin{frame}{Оператор \texttt{return}}
    Оператор \texttt{return} - это механизм возвращения значений из вызываемой функции в вызывающую. После \texttt{return} может идти любое выражение:
    
    \begin{alltt}
    return выражение;
    \end{alltt}
    
    По мере необходимости выражение преобразуется в тип, возвращаемый функцией согласно ее объявлению и определению. Часто выражение заключают в круглые скобки, но это не обязательно.
\end{frame}

\begin{frame}[fragile]{Пример функции}
\begin{minted}{c}
/* strindex: возвращает индекс строки t в s, -1 при 
отсутствии */
int strindex( char s[], char t[]){
    int i, j, k;
    for (i = 0; s[i] != '\0'; i++){
        for (j=i, k=0; t[k]!='\0' && s[j]==t[k]; j++, k++)
            if (k > 0 && t[k] == '\0')
                return i;
    }
    return -1;
}
\end{minted}
\end{frame}

\section{Параметры функций}

\begin{frame}{Аргументы функции}
    В языках программирования имеется два способа передачи значений подпрограмме. Первый из них - передача по значению. При его применении в формальный параметр подпрограммы копируется значение аргумента. В таком случае изменения параметра на аргумент не влияют.
    
    Вторым способом передачи аргументов подпрограмме является передачи по ссылке. При его применении в параметр копируется адрес аргумента. Это значит, что, в отличие от передачи по значению, изменения значения параметра приводят к точно таким же изменениям значения аргумента.
    
    За небольшим количеством исключений, в языке С для передачи аргументов используется передача по значению. Обычно это означает, что код, находящийся внутри функции, не может изменять значений аргументов, которые использовались при вызове функции.
\end{frame}

\begin{frame}[fragile]{Примеры передачи значений функции}
Передача по значению
\begin{minted}{c}
int sqr(int x){
    x = x * x;
    return x;
}
\end{minted}

\\
Передача по ссылке
\begin{minted}{c}
void swap(int *x, int *y){
    int temp;
    temp = *x;  /* сохранить значение по адресу x */
    *x = *y;  /* поместить y в x */
    *y = temp;  /* поместить x в y */
}
\end{minted}
\end{frame}

\section{Функция \texttt{main}}
    
\begin{frame}{Функция \texttt{main}}
    При запуске программы на языке С управление передается функции с именем \texttt{main}, которая должна присутствовать в каждой программе. В полном варианте функция \texttt{main} имеет следующий формат:
    \begin{alltt}
        int main(int argc, char *argv[])\{
        
        \qquad операторы
        
        \qquad return код\_завершения;
        
        \}
    \end{alltt}
    
    С помощью аргументов \texttt{argc} и \texttt{argv} в программу передаются параметры командной строки, заданные при запуске программы. \texttt{код\_завершения} представляет собой целое значение, которое передается в вызывающий процесс. Обычно при успешном (неаварийном) завершении программы \texttt{код\_завершения} равен нулю.
    
    При необходимости результат функции \texttt{main} или ее аргументы могут отсутствовать, например:
    \begin{alltt}
        int main()\{
        
        \qquad операторы
        
        \}
    \end{alltt}
\end{frame}

\begin{frame}{Аргументы функции \texttt{main}}
    С помощью аргументов функции \texttt{main} \texttt{argc} и \texttt{argv} в программу передаются параметры командной строки. 
    Аргумент \texttt{argc} содержит число параметров командной строки. Значение \texttt{argc} всегда не меньше единицы, т.к. первым параметром всегда передается имя программы. 
    
    Аргумент \texttt{argv} представляет собой массив указателей на строки, в каждой из которых передается параметр командной строки с соответствующим номером.
    
    Пусть программный файл \texttt{myprog} был запущен командой
    
    \\ \\
    \texttt{myprog -ig file1.txt}
    \\
    
    В этом случае аргументы будут иметь следующие значения:
    \begin{alltt}
        argc = 3,
        
        argv[0] = “myprog”,
        
        argv[1] = “-ig”,
        
        argv[2] = “file1.txt”
        
        argv[3] = 0
    \end{alltt}
\end{frame}

\begin{frame}[fragile]{Пример}
\begin{minted}[fontsize=\footnotesize]{c}
/* Программа счета в обратном порядке. */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
int main(int argc, char *argv[]) {
    int disp, count;
    if(argc<2) {
        printf("В командной строке необходимо ввести число, с которого\n");
        printf("начинается отсчет. Попробуйте снова.\n");
        exit(1);
    }
    
    if(argc==3 && !strcmp(argv[2], "display")) disp = 1;
    else disp = 0;
    
    for(count=atoi(argv[1]); count; --count)
        if(disp) printf("%d\n", count);
    
    putchar('\a'); /* здесь подается звуковой сигнал */
    printf("Счет закончен");
    return 0;
}
\end{minted}
\end{frame}

\section{Препроцессор}

\begin{frame}{Препроцессор C}
    Некоторые средства языка С реализованы с помощью препроцессора, работа которого по сути является первым этапом компиляции.
    
    Два наиболее часто используемых средства — это директива \texttt{\#include}, включающая все содержимое заданного файла в компилируемый код, и директива \texttt{\#define}, заменяющая некий идентификатор заданной последовательностью символов. 

    Другие средства, которые будут рассмотрены, — это условная компиляция и макросы с аргументами.
\end{frame}


\begin{frame}{Включение файлов. Директива \texttt{\#include}}
    Включение файлов задается одной из следующих строк в исходном коде:
    
    \begin{alltt}
    \#include "имя\_файла"
    
    \#include <имя\_файла>
    \end{alltt}
    
    При обработке текста строка заменяется содержимым файла \texttt{имя\_файла}. Если \texttt{имя\_файла} указано в кавычках, поиск файла обычно начинается с того места, где находится исходный текст программы.
    Если имя файла заключено в угловые скобки < и >, то поиск файла продолжается по правилам, зависящим от реализации языка, как правило в каталоге, предназначенном для хранения заголовочных файлов.
    Обычно, стандартные файлы в директиве \texttt{\#include} указываются в угловых скобках, а файлы пользователя – в кавычках.
    
    Включаемый файл может в свою очередь содержать директивы \texttt{\#include}.
\end{frame}

\begin{frame}{Макроподстановки}
    Следующая конструкция задает макроопределение, или макрос:
    
    \begin{alltt}
    \#define имя\_макроса текст\_для\_замены
    \end{alltt}
    
    Это - макроопределение простейшего вида; всякий раз, когда \texttt{имя\_макроса} встретится в тексте программы после этого определения, оно будет заменено на \texttt{текст\_для\_замены}.
    
    Имя в \texttt{#define} имеет ту же форму, что и имена переменных, а текст для замены может быть произвольным. Обычно \texttt{имя\_макроса} пишут заглавными буквами.
    
    Обычно текст для замены умещается на одной строке, но если он
    слишком длинный, его можно продлить на несколько строк, поставив в конце каждой строки символ продолжения \backslash.
    
    Текст для подстановки может быть совершенно произвольным. Например, таким образом можно определить имя \texttt{forever}, обозначающее бесконечный цикл:
    
    \begin{alltt}
    \#define forever for (;;) /* бесконечный цикл */
    \end{alltt}
    
\end{frame}

\begin{frame}{Макросы с аргументами}
    Можно также определять макросы с аргументами, чтобы изменять текст подстановки в зависимости от способа вызова макроса. Например, так определяется макрос с именем max:
    
    \begin{alltt}
    \#define max(А, В) ((А) > (В) ? (А) : (В))
    \end{alltt}
    
    Хотя внешне он напоминает вызов функции, на самом деле max
    разворачивается прямо в тексте программы путем подстановки. Вместо формальных параметров (А и В) будут подставлены фактические аргументы, обнаруженные в тексте. Возьмем, например, следующий макровызов:
    
    \begin{alltt}
    х = max(p+q, r+s);
    \end{alltt}
    
    При компиляции он будет заменен на следующую строку:
    
    \begin{alltt}
    \alltt{х = ((p+q) > (r+s) ? (p+q) : (r+s));}
    \end{alltt}
    
    Если всегда задавать при вызове соответствующие по типу аргументы, нет необходимости иметь несколько различных макросов \texttt{max} для различных типов данных, как это было бы с функциями.
\end{frame}

\begin{frame}{Побочные эффекты макросов с аргументами}
    Если внимательно изучить способ подстановки макроса \texttt{max}, можно заметить ряд "ловушек".
    
    Так, выражения в развернутой форме макроса вычисляются дважды, и это даст неправильный результат, если в них присутствуют побочные эффекты наподобие инкремента-декремента или ввода-вывода. Например, в следующем макровызове большее значение будет инкрементировано два раза:
    
    \begin{alltt}
    max(i++, j++) /* НЕПРАВИЛЬНО */
    \end{alltt}
    
    Необходимо также аккуратно использовать скобки, чтобы гарантировать правильный порядок вычислений. Представьте себе, что произойдет, если следующий макрос вызвать в виде \texttt{square(z + 1)}:
    
    \begin{alltt}
    \#define square(x) x * x /* НЕПРАВИЛЬНО */
    \end{alltt}
\end{frame}

\begin{frame}{Директива \texttt{\#undef}}
    Директива \texttt{\#undef} удаляет ранее заданное определение имени макроса, то есть "аннулирует" его определение; само имя макроса должно находиться после директивы.
    
    В общем виде директива \texttt{\#undef} выглядит таким образом:
    
    \begin{alltt}
    \#undef имя\_макроса
    \end{alltt}
    
    Директива \texttt{\#undef} используется в основном для того, чтобы локализовать имена макросов в тех участках кода, где они нужны.
\end{frame}

\begin{frame}{Условная компиляция}
    Существует возможность управлять самой препроцессорной обработкой, используя условные директивы, которые выполняются по ходу этой обработки.
    
    Это делает возможным условное включение фрагментов кода в программу в зависимости от условий, выполняющихся в момент компиляции.
    
    К директивам условной компиляции относятся директивы:
    \begin{itemize}
        \item \texttt{\#if},
        \item \texttt{\#else},
        \item \texttt{\#elif},
        \item \texttt{\#endif},
        \item \texttt{\#ifdef},
        \item \texttt{\#ifndef}.
    \end{itemize}
\end{frame}

\begin{frame}{Директивы \texttt{#if} и \texttt{#endif}}
    Директивы \texttt{\#if} и \texttt{\#endif} дают возможность в зависимости от значения константного выражения включать или исключать те или иные части кода. В простейшем виде директива \texttt{\#if} выглядит таким образом:
    
    \begin{alltt}
        \#if константное\_выражение
        
        \qquad последовательность операторов
        
        \#endif
    \end{alltt}
    
    Если находящееся за \texttt{\#if} константное выражение истинно, то компилируется код, который находится между этим выражением и \texttt{\#endif}.В противном случае этот промежуточный код пропускается.
    
    Директива \texttt{\#endif} обозначает конец блока \texttt{\#if}.
\end{frame}

\begin{frame}{Директивы \texttt{\#else} и \texttt{\#elif}}
    Директива \texttt{\#else} позволяет в блоке \texttt{\#if-\#endif} выбрать для включения в программу один из двух возможных фрагментов кода в зависимости от истинности или ложности заданного константного выражения
    
    \\
    \begin{alltt}
        \#if константное выражение
        
        \qquad последовательность операторов 1 /* выражение истинно */
        
        \#else
        
        \qquad последовательность операторов 2 /* выражение ложно */
        
        \#endif
    \end{alltt}
    
    \\
    Директива \texttt{\#elif} эквивалентна комбинации директив \texttt{\#else} и \texttt{\#if}. Директива \texttt{\#elif} позволяет организовать выбор одного из нескольких фрагментов кода для включения в программу. При этом фрагмент кода включается в программу когда истинно соответствующее ему константное выражение.
\end{frame}

\begin{frame}{Формат директивы \texttt{\#elif}}
    \begin{alltt}
        \#if выражение
        
        \qquad последовательность операторов
        
        \#elif выражение 1
        
        \qquad последовательность операторов
        
        \#elif выражение 2
        
        \qquad последовательность операторов
        
        \#elif выражение 3
        
        \qquad последовательность операторов
        
        \#elif выражение 4
        
        . . .
        
        \#elif выражение N
        
        \qquad последовательность операторов
        
        \#endif
    \end{alltt}
\end{frame}

\begin{frame}[fragile]{Пример условной компиляции}
    В следующем фрагменте кода анализируется \texttt{SYSTEM} и принимается решение, какую версию заголовочного файла включать в программу:
    
    \begin{minted}{c}
    #if SYSTEM == WIN_9X
        #define HDR “win9x.h"
    #elif SYSTEM == WIN_NT
        #define HDR “winnt.h"
    #elif SYSTEM == LINUX
        #define HDR “linux.h"
    #else
        #define HDR "default.h"
    #endif
    
    #include HDR
    \end{minted}
\end{frame}

\begin{frame}{Директивы \texttt{\#ifdef} и \texttt{\#ifndef}}
    Другой способ условной компиляции — это использование директив \texttt{\#ifdef} и \texttt{\#ifndef}, которые соответственно означают "if defined" (если определено) и "if not defined" (если не определено). В общем виде \texttt{\#ifdef} выглядит таким образом:
    
    \begin{alltt}
        \#ifdef имя\_макроса
        
        \qquad последовательность операторов
        
        \#endif
    \end{alltt}
    
    Блок кода будет компилироваться, если имя макроса было определено ранее в директиве \texttt{\#define}.
    
    В общем виде директива \texttt{\#ifndef} выглядит таким образом:
    
    \begin{alltt}
        \#ifndef имя\_макроса
        
        \qquad последовательность операторов
        
        \#endif
    \end{alltt}
    
    Блок кода будет компилироваться, если имя макроса еще не определено в директиве \texttt{\#define}. И в \texttt{\#ifdef}, и в \texttt{\#ifndef} можно использовать директивы \texttt{\#else} или \texttt{\#elif}.
\end{frame}

\section{Заголовочные файлы}

\begin{frame}{Заголовочные файлы}
    Большую программу затруднительно разместить в одном файле исходного кода. Ее приходится разбивать на несколько файлов исходного кода, содержащих переменные и функции, которые могут компилироваться отдельно. При этом необходимо дать ответы на следующие вопросы:
    
    \begin{itemize}
        \item Как записать объявления переменных, чтобы они правильно воспринимались во время компиляции?
        \item Как организовать объявления так, чтобы при компоновке программы все ее части правильно
        объединились в одно целое?
        \item Как организовать объявления так, чтобы каждая переменная присутствовала в одном экземпляре?
        \item Как инициализируются внешние переменные?
    \end{itemize}
    
    В языке C принят способ выделения части объектов программы в так называемые заголовочные файлы (имеющие расширение *.h). В заголовочные файлы выносят объявления переменных и функций, а их определения размещают в обычных файлах исходного кода (*.c).
\end{frame}

\begin{frame}{Заголовочные файлы}
    В заголовочном файле могут содержаться:
    \begin{itemize}
    \item Определения типов \texttt{struct point { int x, y; };}
    \item Описания функций \texttt{extern int strlen(const char*);}
    \item Описания данных \texttt{extern int a;}
    \item Определения констант \texttt{const float pi = 3.141593;}
    \item Перечисления \texttt{enum bool { false, true };}
    \item Директивы include \texttt{\#include}
    \item Определения макросов \texttt{\#define Case break;case}
    \item Комментарии \texttt{/* проверка на конец файла */}
    \end{itemize}

    В заголовочных файлах НЕ содержатся:
    \begin{itemize}
        \item Определения обычных функций \texttt{char get() { return *p++; }}
        \item Определения данных \texttt{int a;}
        \item Определения сложных константных объектов \texttt{const tbl[] = { /* ... */ }}
    \end{itemize}
    \end{frame}

\end{document}