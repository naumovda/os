# Лабораторная работа №7. Файловая система Linux
Целью работы является изучение механизмов чтения информации о файловой системе, чтения каталогов и выполнения операций над файлами.

## МЕТОДИЧЕСКИЕ МАТЕРИАЛЫ

### 1. Чтение информации о файловой системе

#### Рассмотрим пример (листинг 1), демонстрирующий работу функции statvfs().

В представленной программе функция `setmntent()` открывает файл /etc/mtab для чтения. Затем функция `getmntent()` вызывается в цикле для последовательного считывания всех записей /etc/mtab. Для каждой файловой системы вызывается функция `statvfs()`. И, наконец, функция `endmntent()` закрывает файл.

Обратите внимание, что точка монтирования является элементом соответствующей файловой системы и может быть указана первым аргументом `statvfs()`. Элементы структуры `statvfs` приводятся к беззнаковому длинному целому типу. Это обусловлено тем, что современные файловые системы могут содержать в данных полях достаточно большие значения. 

Листинг 1.1:
```cpp
#include <sys/statvfs.h>
#include <mntent.h>
#include <stdio.h>

int main (void)
{
    struct mntent * entry;
    struct statvfs fs;
    FILE * file;
    
    file = setmntent ("/etc/mtab", "r");
    if (file == NULL) {
        fprintf (stderr, "Cannot open /etc/mtab\n");
        return 1;
    }

    while ((entry = getmntent (file)) != NULL) {
        if (statvfs (entry->mnt_dir, &fs) == -1) {
            fprintf (stderr, "statvfs() error\n");
            return 1;
        }

        printf ("Filesystem: %s\n", entry->mnt_fsname);
        printf ("Mountpoint: %s\n", entry->mnt_dir);
        printf ("Block size: %ld\n", (unsigned long int)
            fs.f_bsize);
        printf ("Blocks: %ld\n", (unsigned long int)
            fs.f_blocks);
        printf ("Blocks free: %ld\n", (unsigned long int)
            fs.f_bfree);
        printf ("Blocks available: %ld\n",
            (unsigned long int) fs.f_bavail);
        printf ("Max. filename length: %ld\n",
            (unsigned long int) fs.f_namemax);
        printf ("---\n");
    }

    endmntent (file);    
    return 0;
}
```

#### Следующий пример (листинг 1.2) показывает, как работает функция fstatvfs()

Листинг 1.2:
```cpp
#include <sys/statvfs.h>
#include <fcntl.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
    struct statvfs fs;
    int fd;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }
    
    fd = open (argv[1], O_RDONLY);
    if (fd == -1) {
        fprintf (stderr, "Cannot open file (%s)\n", argv[1]);
        return 1;
    }

    if (fstatvfs (fd, &fs) == -1) {
        fprintf (stderr, "fstatvfs() error\n");
        return 1;
    }

    printf ("Block size: %ld\n", (unsigned long int) fs.f_bsize);
    printf ("Blocks: %ld\n", (unsigned long int) fs.f_blocks);
    printf ("Blocks free: %ld\n", (unsigned long int) fs.f_bfree);
    printf ("Blocks available: %ld\n", (unsigned long int) fs.f_bavail);
    printf ("Max. filename length: %ld\n", (unsigned long int) fs.f_namemax);
    
    close (fd);
    return 0;
}
```

#### Получение текущего каталога

Ядро хранит определенный набор параметров для каждого процесса, и одним из таких параметров является текущий каталог.

Каждый дочерний процесс наследует от своего родителя независимую копию текущего каталога. В этом можно легко убедиться:

Листинг 1.3:

```bash
$ cd /etc
$ bash
$ pwd
/etc
$ exit
exit
```

Для получения значения текущего каталога используется системный вызов `getcwd()`, объявленный в заголовочном файле unistd.h следующим образом: 

```cpp
char * getcwd (char * BUFFER, size_t SIZE);
```

Если в качестве аргумента `BUFFER` указан `NULL`, то `getcwd()` динамически выделяет блок памяти размером `SIZE` байт и возвращает адрес этого блока, предварительно поместив туда значение текущего каталога.

Можно также указать в первом аргументе собственный буфер, а во второй аргумент записать его размер. В этом случае `getcwd()` поместит в данный буфер значение текущего каталога. 

Следует отметить, что `getcwd()` помещает в буфер полный путь к текущему каталогу. Чтобы  получить только базовое имя каталога, можно воспользоваться функцией `basename()`, объявленной в заголовочном файле string.h следующим образом:

```cpp
char * basename (const char * PATH);
```

Эта функция "отсекает" путь и возвращает только базовое имя файла или каталога.

Рассмотрим пример (листинг 1.4), демонстрирующий работу системного вызова `getcwd()`.

Листинг 1.4:
```cpp
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PWD_BUF_SIZE 1024

int main (void)
{
    char * buf = (char*) malloc (PWD_BUF_SIZE * sizeof (char));    
    if (buf == NULL) {
        fprintf (stderr, "buf is NULL\n");
        return 1;
    }

    buf = getcwd (buf, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("Current directory: %s\n", buf);
    printf ("Basename: %s\n", basename (buf));

    free (buf);
    return 0;
}
```

Листинг 1.5 содержит другой пример, который тоже выводит значение текущего каталога, но возлагает обязанности выделения памяти на системный вызов `getcwd()`.

Листинг 1.5:
```cpp
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PWD_BUF_SIZE 1024

int main (void)
{
    char * buf;
    if (buf == NULL) {
        fprintf (stderr, "buf is NULL\n");
        return 1;
    }

    buf = getcwd (NULL, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("Current directory: %s\n", buf);
    printf ("Basename: %s\n", basename (buf));

    free (buf);
    return 0;
}
```

### 2. Чтение каталогов

#### Смена текущего каталога

Любой процесс может сменить свой текущий каталог. Это можно сделать при помощи одного из приведенных далее системных вызовов, объявленных в заголовочном файле unistd.h:

```cpp
int chdir (const char * PATH);
int fchdir (int FD);
```

Обе функции возвращают 0 при успешном завершении и –1, если произошла ошибка. Системный вызов `chdir()` изменяет текущий каталог, используя его имя (путь), а `fchdir()` вместо имени читает файловый дескриптор каталога.

Листинг 2.1 иллюстрирует пример работы системного вызова `chdir()`.

```cpp
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>

#define PWD_BUF_SIZE 1024
#define FILE_BUF_SIZE 4096

char file_buf [FILE_BUF_SIZE];

int main (void)
{
    int fd;
    ssize_t count;
    
    char * buf = getcwd (NULL, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("Old dir: %s\n", buf);
    free (buf);

    if (chdir ("/etc") == -1) {
        fprintf (stderr, "chdir() error\n");
        return 1;
    }

    buf = getcwd (NULL, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("New dir: %s\n", buf);
    free (buf);
    fd = open ("fstab", O_RDONLY);

    if (fd == -1) {
        fprintf (stderr, "Cannot open fstab\n");
        return 1;
    }

    printf ("FSTAB:\n");

    while ((count = read (fd, file_buf, FILE_BUF_SIZE)) > 0)
        write (1, file_buf, count);

    close (fd);
    return 0;
}
```

Эта программа сначала выводит на экран начальное значение текущего каталога. Затем текущий каталог сменяется на /etc. После этого мы заново вызываем `getcwd()`, чтобы убедиться, что текущим каталогом теперь действительно является /etc. Наконец, чтобы окончательно удостовериться в том, что текущий каталог успешно изменен, мы читаем файл /etc/fstab, указав системному вызову `open()` только имя fstab.

Обратите внимание, что функция `free()` для указателя buf вызывается дважды.
Если системному вызову `getcwd()` передать NULL в качестве первого аргумента, то возвращенный указатель будет ссылаться на динамически выделенную память. 
Если бы мы не вызвали `free()` после первого чтения текущего каталога, то повторный вызов `getcwd()` привел бы к потере предыдущего указателя.

Переделаем нашу программу (листинг 2.1), заменив системный вызов `chdir()` на `fchdir()`(листинг 2.2). Этот пример показывает, что для смены каталога не обязательно знать его имя.

Листинг 2.2:
```cpp
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>

#define PWD_BUF_SIZE 1024
#define FILE_BUF_SIZE 4096

char file_buf [FILE_BUF_SIZE];

int main (void)
{
    int fd, dirfd;
    ssize_t count;

    char * buf = getcwd (NULL, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("Old dir: %s\n", buf);
    free (buf);

    dirfd = open ("/etc", O_RDONLY);
    if (dirfd == -1) {
        fprintf (stderr, "Cannot open /etc\n");
        return 1;
    }

    if (fchdir (dirfd) == -1) {
        fprintf (stderr, "fchdir() error\n");
        return 1;
    }

    buf = getcwd (NULL, PWD_BUF_SIZE);
    if (buf == NULL) {
        fprintf (stderr, "getcwd() error\n");
        return 1;
    }

    printf ("New dir: %s\n", buf);

    free (buf);

    fd = open ("fstab", O_RDONLY);
    if (fd == -1) {
        fprintf (stderr, "Cannot open fstab\n");
        return 1;
    }

    printf ("FSTAB:\n");

    while ((count = read (fd, file_buf, FILE_BUF_SIZE)) > 0)
        write (1, file_buf, count);

    close (fd);
    close (dirfd);
    return 0;
}
```

#### Открытие и закрытие каталога

В рамках этой работы мы будем учиться читать содержимое каталогов при помощи библиотечных механизмов стандартной библиотеки языка C, которые (в большинстве случаев) более удобны, чем аналогичные системные вызовы.

Поскольку пользовательские библиотеки располагаются на верхнем уровне реализации файловой системы, то каталог здесь рассматривается как самостоятельная сущность, не являющаяся особым файловым типом. Поэтому библиотечная абстракция файла — указатель типа `FILE` — не может применяться к каталогам.

В стандартной библиотеке языка C абстракцией каталога является указатель типа `DIR`. Прежде чем читать содержимое каталога, его нужно открыть, а прочитанный каталог полагается закрывать. Для этого существуют следующие функции, объявленные в заголовочном файле dirent.h:

```cpp
DIR * opendir (const char * NAME);
int closedir (DIR * DIRP);
```

Первая функция открывает каталог с именем `NAME` и возвращает указатель типа `DIR`.
В случае ошибки возвращается `NULL`. Функция `closedir()` закрывает каталог и возвращает 0 при успешном завершении. В случае ошибки `closedir()` возвращает –1.

Каталог можно также открыть при помощи функции `fdopendir()`, которая вместо
имени каталога использует файловый дескриптор:

```cpp
DIR * fdopendir (int FD);
```

По своему поведению `fdopendir()` напоминает функцию `fdopen()`.

#### Чтение каталога

Для чтения содержимого каталога применяется функция `readdir()`, объявленная в заголовочном файле dirent.h следующим образом:

```cpp
struct dirent * readdir (DIR * DIRP);
```

Структура `dirent` содержит несколько полей, но нам понадобится только одно из них:

```cpp
struct dirent {
/* ... */
char * d_name;
};
```

Итак, функция `readdir()` заносит в поле `d_name` структуры `dirent` имя очередного элемента просматриваемого каталога. Если каталог полностью просмотрен, то `readdir()` возвращает `NULL`.

Следующая программа (листинг 2.3) выводит на экран содержимое указанного каталога примерно так же, как это делает программа ls с набором флагов -1fa (в одну колонку, не сортируя, все файлы).

Листинг 2.3
```cpp
#include <stdio.h>
#include <dirent.h>

int main (int argc, char ** argv)
{
    DIR * dir;
    struct dirent * entry;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    dir = opendir (argv[1]);
    if (dir == NULL) {
        fprintf (stderr, "opendir() error\n");
        return 1;
    }

    while ((entry = readdir (dir)) != NULL)
        printf ("%s\n", entry->d_name);
    
    closedir (dir);
    
    return 0;
}
```

#### Повторное чтение каталога
Бывают ситуации, когда требуется повторно прочитать каталог. Для этого, конечно, можно закрыть, а потом заново открыть этот каталог. Но есть более простой способ установки текущей позиции чтения каталога на первый элемент. Это делает функция `rewinddir()`, объявленная в файле dirent.h следующим образом:

```cpp
void rewinddir (DIR * DIRP);
```

Рассмотрим сразу пример (листинг 2.4), который демонстрирует работу этой функции.

Листинг 2.4:

```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

int main (int argc, char ** argv)
{
    struct stat st;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (stat (argv[1], &st) == -1) {
        fprintf (stderr, "stat() error\n");
        return 1;
    }

    printf ("FILE:\t\t%s\n", argv[1]);
    printf ("UID:\t\t%d\n", (int) st.st_uid);
    printf ("GID:\t\t%d\n", (int) st.st_gid);
    printf ("SIZE:\t\t%ld\n", (long int) st.st_size);
    printf ("AT:\t\t%s", ctime (&st.st_atime));
    printf ("MT:\t\t%s", ctime (&st.st_mtime));

    return 0;
}
```

#### Получение данных о файлах: семейство stat()

В большинстве случаев при просмотре каталога мало знать только имя файла. Дополнительную информацию о файлах позволяют получить системные вызовы семейства `stat()`, объявленные в заголовочном файле sys/stat.h:

```cpp
int stat (const char * FNAME, struct stat * STATISTICS);
int fstat (int FD, struct stat * STATISTICS);
int lstat (const char * FNAME, struct stat * STATISTICS);
```

Системный вызов `stat()` читает информацию о файле с именем `FNAME` и записывает эту информацию в структуру `stat` по адресу `STATISTICS`. 
Вызов `fstat()` также читает информацию о файле, который представлен дескриптором `FD`. 
И, наконец, `lstat()` работает аналогично `stat()`. Но при обнаружении символической ссылки `lstat()` читает информацию о ней, а не о файле, на который эта ссылка указывает.

Структура `stat` также объявлена в файле sys/stat.h. Для нас наибольший интерес представляют следующие поля этой структуры:

```cpp
struct stat
{
    mode_t st_mode;
    uid_t st_uid;
    gid_t st_gid;
    off_t st_size;
    time_t st_atime;
    time_t st_mtime;
}
```

Перечислим назначение полей структуры `stat`:
- st_mode — это режим файла. Позже в этом разделе мы узнаем секрет его использования;
- st_uid — это числовой идентификатор владельца файла;
- st_gid — идентификатор группы;
- st_size — это размер файла в байтах;
- st_atime — содержит дату и время последнего обращения к файлу;
- st_mtime — содержит дату и время последней модификации файла.

Все системные вызовы семейства `stat()` возвращают 0 при успешном завершении.
В случае ошибки возвращается –1. Следующий пример (листинг 2.5) демонстрирует использование системного вызова `stat()`.

Листинг 2.5:

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <fcntl.h>

int main (int argc, char ** argv)
{
    struct stat st;
    int fd;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_RDONLY);
    if (fd == -1) {
        fprintf (stderr, "Cannot open file (%s)\n", argv[1]);
        return 1;
    }
    
    if (fstat (fd, &st) == -1) {
        fprintf (stderr, "stat() error\n");
        return 1;
    }

    printf ("FILE:\t\t%s\n", argv[1]);
    printf ("UID:\t\t%d\n", (int) st.st_uid);
    printf ("GID:\t\t%d\n", (int) st.st_gid);
    printf ("SIZE:\t\t%ld\n", (long int) st.st_size);
    printf ("AT:\t\t%s", ctime (&st.st_atime));
    printf ("MT:\t\t%s", ctime (&st.st_mtime));

    close (fd);
    return 0;
}
```
Рассмотрим теперь пример системного вызова `fstat()` (листинг 2.6)

Листинг 2.6:

```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

void print_statistics (const char * fname, struct stat * st)
{
    printf ("FILE:\t\t%s\n", fname);
    printf ("UID:\t\t%d\n", (int) st->st_uid);
    printf ("GID:\t\t%d\n", (int) st->st_gid);
    printf ("SIZE:\t\t%ld\n", (long int) st->st_size);
    printf ("AT:\t\t%s", ctime (&st->st_atime));
    printf ("MT:\t\t%s", ctime (&st->st_mtime));
}

int main (int argc, char ** argv)
{
    struct stat st;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (stat (argv[1], &st) == -1) {
        fprintf (stderr, "stat() error\n");
        return 1;
    }

    printf ("-- STAT() --\n");
    print_statistics (argv[1], &st);

    if (lstat (argv[1], &st) == -1) {
        fprintf (stderr, "lstat() error\n");
        return 1;
    }
    
    printf ("-- LSTAT() --\n");
    print_statistics (argv[1], &st);
    
    return 0;
}
```

На первый взгляд обе программы работают абсолютно одинаково. Но давайте проведем небольшой эксперимент:

```
$ touch myfile
$ chmod 000 myfile
$ ls -l myfile
---------- 1 nnivanov nnivanov 0 2011-05-07 09:24 myfile
$ ./stat1 myfile
FILE: myfile
UID: 500
GID: 500
SIZE: 0
AT: Sat May 7 09:24:17 2011
MT: Sat May 7 09:24:17 2011
$ ./stat2 myfile
Cannot open file (myfile)
```

Итак, программа `stat1` (см. листинг 2.5) оказалась в преимущественном положении, поскольку системный вызов `stat()` может читать информацию о файлах с любыми правами доступа.

Рассмотрим теперь пример системного вызова `lstat()` (листинг 2.7).

Листинг 2.7:

```cpp
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/stat.h>

void print_stat (const char * fname)
{
    struct stat st;

    if (lstat (fname, &st) == -1) {
        fprintf (stderr, "lstat() error\n");
        exit (1);
    }

    if (S_ISDIR (st.st_mode))
        printf ("dir");
    else if (S_ISCHR (st.st_mode))
        printf ("chrdev");
    else if (S_ISBLK (st.st_mode))
        printf ("blkdev");
    else if (S_ISREG (st.st_mode))
        printf ("regfile");
    else if (S_ISFIFO (st.st_mode))
        printf ("fifo");
    else if (S_ISLNK (st.st_mode))
        printf ("symlink");
    else if (S_ISSOCK (st.st_mode))
        printf ("socket");
    else
        printf ("unknown");

    printf (", %d\n", st.st_size);
}

int main (int argc, char ** argv)
{
    DIR * dir;
    struct dirent * entry;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    dir = opendir (argv[1]);
    if (dir == NULL) {
        fprintf (stderr, "opendir() error\n");
        return 1;
    }

    while ((entry = readdir (dir)) != NULL) {
        printf ("%s\t\t", entry->d_name);    

        if (chdir (argv[1]) == -1) {
            fprintf (stderr, "chdir() error\n");
            return 1;
        }
        
        print_stat (entry->d_name);
    }
    
    closedir (dir);
    return 0;
}
```

Вот что получилось в результате:

```
$ touch myfile
$ ln -s myfile mylink
$ ./stat3 myfile
-- STAT() --
FILE: myfile
UID: 500
GID: 500
SIZE: 0
AT: Sat May 7 09:59:14 2011
MT: Sat May 7 09:59:14 2011
-- LSTAT() --
FILE: myfile
UID: 500
GID: 500
SIZE: 0
AT: Sat May 7 09:59:14 2011
MT: Sat May 7 09:59:14 2011
$ ./stat3 mylink
-- STAT() --
FILE: mylink
UID: 500
GID: 500
SIZE: 0
AT: Sat May 7 09:59:14 2011
MT: Sat May 7 09:59:14 2011
-- LSTAT() --
FILE: mylink
UID: 500
GID: 500
SIZE: 6
AT: Sat May 7 09:59:52 2011
MT: Sat May 7 09:59:24 2011
```

Приведенный эксперимент доказывает, что системные вызовы `stat()` и `lstat()` поразному интерпретируют символические ссылки, но ведут себя одинаково по отношению к другим типам файлов.

Вернемся теперь к полю `st_mode` структуры `stat`, которое мы до сих пор игнорировали. Биты режима файла делятся на три группы:
- базовые права доступа;
- расширенные права доступа;
- тип файла.

Для проверки базовых прав доступа достаточно сравнить режим файла с одной из констант из sys/types.h (S_IRUSR, S_IWUSR и т. п.) с использованием операции побитовой конъюнкции (И). Например, если владельцу разрешено писать в файл, то следующее выражение будет истинным:
`mode & S_IWUSR`.

Аналогичным образом проверяются расширенные права доступа:
- константа S_ISUID используется для установки и проверки бита SUID;
- константа S_ISGID служит для установки и проверки бита SGID;
- константа S_ISVTX предназначена для установки и проверки sticky-бита.

Таким образом, если, например, для исполняемого файла с режимом mode установлен бит SUID, то следующее выражение будет истинным: `mode & S_ISUID`.

А для определения типа файла применяются следующие макросы:
- S_ISDIR(mode) — каталог;
- S_ISCHR(mode) — символьное устройство;
- S_ISBLK(mode) — блочное устройство;
- S_ISREG(mode) — обычный файл;
- S_ISFIFO(mode) — именованный канал FIFO;
- S_ISLNK(mode) — символическая ссылка;
- S_ISSOCK(mode) — сокет.

Давайте теперь напишем программу, которая читает содержимое каталога и выводит тип и размер каждого файла (листинг 2.8).

Листинг 2.8:

```cpp
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>

#define READLNK_BUF_SIZE 1024

char readlnk_buf [READLNK_BUF_SIZE+1];

void print_link_info (const char * fname)
{
    int count = readlink (fname, readlnk_buf, READLNK_BUF_SIZE);

    if (count == -1) {
        fprintf (stderr, "readlink() error\n");
        exit (1);
    }

    readlnk_buf [count] = '\0';

    printf ("%s --> %s", fname, readlnk_buf);
}

void print_stat (const char * fname)
{
    struct stat st;

    if (lstat (fname, &st) == -1) {
        fprintf (stderr, "lstat() error\n");
        exit (1);
    }

    if (S_ISDIR (st.st_mode))
        printf ("dir");
    else if (S_ISCHR (st.st_mode))
        printf ("chrdev");
    else if (S_ISBLK (st.st_mode))
        printf ("blkdev");
    else if (S_ISREG (st.st_mode))
        printf ("regfile");
    else if (S_ISFIFO (st.st_mode))
        printf ("fifo");
    else if (S_ISLNK (st.st_mode))
        print_link_info (fname);
    else if (S_ISSOCK (st.st_mode))
        printf ("socket");
    else
        printf ("unknown");

    printf (", %d\n", st.st_size);
}

int main (int argc, char ** argv)
{
    DIR * dir;
    struct dirent * entry;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    dir = opendir (argv[1]);
    if (dir == NULL) {
        fprintf (stderr, "opendir() error\n");
        return 1;
    }

    while ((entry = readdir (dir)) != NULL) {
        printf ("%s\t\t", entry->d_name);
    
        if (chdir (argv[1]) == -1) {
            fprintf (stderr, "chdir() error\n");
            return 1;
        }

        print_stat (entry->d_name);
    }
    
    closedir (dir);
    return 0;
}
```

Обратите внимание, что в приведенной программе чтение информации о файлах реализует системный вызов `lstat()`. Если бы мы использовали `stat()`, то символические ссылки заменялись бы файлами, на которые они указывают, и макрос `S_ISLNK()` никогда не принимал бы истинные значения.

#### Чтение ссылок: readlink()

Программа ls, вызванная с флагом –l, позволяет узнать, на какой файл указывает символическая ссылка:

```
$ touch myfile
$ ln -s myfile mylink
$ ls -l mylink
lrwxrwxrwx 1 nnivanov nnivanov 6 2011-05-07 09:59 mylink -> myfile
```

Такая операция называется разыменованием символической ссылки (symlink dereferencing) или разрешением имени файла (filename resolution). Разыменование символических ссылок осуществляется при помощи системного вызова `readlink()`, который объявлен в заголовочном файле unistd.h следующим образом:

```cpp
ssize_t readlink (const char * SYMLNK, char * BUF, size_t SIZE);
```

Этот системный вызов помещает в буфер `BUF` размера `SIZE` путь к файлу, на который указывает символическая ссылка `SYMLNK`. Возвращаемое значение — число байтов, записанных в буфер `BUF`. В случае ошибки возвращается –1.
Следует отметить, что системный вызов `readlink()` не завершает буфер нультерминатором. Об этом программист должен заботиться самостоятельно.

### 3. Операции над файлами

#### Удаление файла

Для удаления файла служит системный вызов `unlink()`, объявленный в заголовочном файле unistd.h следующим образом:

```cpp
int unlink (const char * FNAME);
```

Аргумент `FNAME` — это имя удаляемого файла. `unlink()` возвращает 0 при успешном
завершении. В случае ошибки возвращается –1.

Следующая программа (листинг 3.1) показывает, как работает системный вызов `unlink()`.

Листинг 3.1:

```cpp
#include <stdio.h>
#include <unistd.h>

int main (int argc, char ** argv)
{
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (unlink (argv[1]) == -1) {
        fprintf (stderr, "Cannot unlink file "
            "(%s)\n", argv[1]);
        return 1;
    }

    return 0;
}
```

На первый взгляд все кажется простым и понятным. Но возникает вопрос: почему создатели UNIX назвали этот системный вызов странным именем unlink(), а не remove() или delete(), например? А все дело в том, что файл — это комплексное понятие, состоящее из следующих компонентов:
- данные (data);
- индексы (inodes);
- ссылки (links).

Реальные файловые системы обычно располагаются на блочных устройствах. Данные на таких устройствах в действительности адресуются блоками фиксированного размера, а не отдельными байтами.
Индексы — это специальные ячейки памяти, зарезервированные файловой системой для разделения смешанных "в одну кучу" данных на отдельные структурные единицы, которые мы называем файлами. Индексы содержат информацию о том, в каких блоках файловой системы хранятся данные конкретного файла. В индексах также содержатся сведения о дате и времени открытия и модификации файла. Иногда индексы называют индексными узлами. Каждый индекс имеет уникальный в рамках данной файловой системы номер.
Ссылки — это привычное для нас отображение файлов в файловой системе. Можно условно сказать, что ссылки являются именами индексных узлов файловой системы. Каталоги можно рассматривать как особые файлы, предназначенные для хранения ссылок на индексные узлы. Программа ls, вызванная с флагом -i, позволяет увидеть номер индексного узла, на который указывает ссылка. 

Проведем небольшой эксперимент:

```
$ mkdir idemo
$ cd idemo
$ touch file1
$ touch file2
$ ls -i
952139 file1 952141 file2
```

Итак, приведенный пример показывает, что file1 — это ссылка на индекс с номером 952139 (у вас он, скорее всего, будет другим). А ссылка file2 указывает на другой индексный узел с номером 952141. Продолжим эксперимент:

```
$ ln -s file1 symlnkf1
$ ls -i
952139 file1 952141 file2 952190 symlnkf1
```

Вывод программы ls показывает, что символическая ссылка является также ссылкой на индекс с номером 952190. Важно понимать, что символические ссылки указывают не на индекс, а на имя файла.

Теперь воспользуемся командой ln без флага -s:
```
$ ln file1 hardfile1
$ ls -i
952139 file1 952141 file2 952139 hardfile1 952190 symlnkf1
```

Вы, наверное, знаете, что наряду с символическими существуют также жесткие ссылки. hardfile1 является жесткой ссылкой на файл file1. Вывод команды ls показывает, что file1 и hardfile1 указывают на один и тот же индекс с номером 952139. На самом деле жесткие ссылки (в отличие от символических) не носят подчиненный характер. Следовательно, file1 и hardfile1 — это полноценные ссылки на один и тот же индексный узел.

Индексы являются промежуточным звеном, связывающим ссылку с данными на блочном устройстве. Если две ссылки указывают на один и тот же индекс, то можно сказать, что они имеют доступ к одним и тем же данным. Это легко проверить:

```
$ echo hello > file1
$ cat hardfile1
hello
```

Теперь мы можем сказать, что программа rm работает следующим образом:
- если удаляемый файл является последней ссылкой на соответствующий индексный узел в файловой системе, то данные и индекс освобождаются;
- если в файловой системе еще остались ссылки на соответствующий индексный узел, то удаляется только ссылка.

Проверим это:
```
$ rm file1
$ cat hardfile1
hello
```

Теперь обратите внимание на вывод программы ls с флагом -l:
```
$ ls -l
-rw-r--r-- 1 nnivanov nnivanov 0 2011-05-07 10:00 file2
-rw-r--r-- 1 nnivanov nnivanov 6 2011-05-07 10:00 hardfile1
lrwxrwxrwx 1 nnivanov nnivanov 5 2011-05-07 10:00 symlnkf1 -> file1
```

Символическая ссылка symlnkf1 по-прежнему указывает на файл file1, которого уже не существует:

```
$ cat symlnkf1
cat: symlnkf1: No such file or directory
```

Обратите внимание на числа во втором столбце вывода программы ls. Это счетчики ссылок на соответствующие индексные узлы. В нашем случае, например, на индексный узел 952141 указывает всего одна ссылка file2. Поэтому удаление file2 командой rm приведет к освобождению индекса 952141. Но если мы создадим еще одну ссылку, то счетчик индексов увеличится:

```
$ ls -l
-rw-r--r-- 2 nnivanov nnivanov 0 2011-05-07 10:00 file2
-rw-r--r-- 1 nnivanov nnivanov 6 2011-05-07 10:00 hardfile1
-rw-r--r-- 2 nnivanov nnivanov 0 2011-05-07 10:00 hardfile2
lrwxrwxrwx 1 nnivanov nnivanov 5 2011-05-07 10:00 symlnkf1 -> file1
```

Теперь во втором столбце вывода ls напротив file2 и hardfile2 находится число 2, символизирующее о том, что на соответствующий индексный узел указывают две ссылки.
Если вызвать команду df с флагом -i, то на экран будет выведена информация по
индексным узлам смонтированных файловых систем:
```
$ df -i
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/sda6 1311552 264492 1047060 21% /
udev 96028 487 95541 1% /dev
/dev/sda1 66264 58 66206 1% /boot
/dev/sda7 3407872 149600 3258272 5% /home
```

В файловых системах может присутствовать ограниченное число индексов (столбец Inodes). Столбец IUsed показывает число используемых индексов, а в столбце IFree содержится число свободных индексных узлов файловой системы. Итак, каждый раз при создании файла в файловой системе выделяется индекс:
```
$ df -i .
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/sda7 3407872 149586 3258286 5% /home
$ touch file3
$ df -i .
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/sda7 3407872 149587 3258285 5% /home
```

А создание жесткой ссылки не приводит к появлению в файловой системе нового индекса:
```
$ df -i .
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/sda7 3407872 149587 3258285 5% /home
$ ln file3 hardfile3
$ df -i .
Filesystem Inodes IUsed IFree IUse% Mounted on
/dev/sda7 3407872 149587 3258285 5% /home
```

Вернемся теперь к программе `statvfsdemo` (листинг 1.1). Эта программа использовала функцию `statvfs()` для вывода информации о смонтированных файловых системах. Структура `statvfs` содержит также следующие поля, которые мы не рассматривали:
- f_files — общее число индексов для данной файловой системы;
- f_free — число свободных индексов файловой системы;
- f_favail — число доступных индексов в файловой системе.

Листинг 3.2 содержит дополненную версию программы statvfsdemo, выводящую также информацию об индексах для каждой файловой системы.

```cpp
#include <sys/statvfs.h>
#include <mntent.h>
#include <stdio.h>

int main (void)
{
    struct mntent * entry;
    struct statvfs fs;
    FILE * file;
   
    file = setmntent ("/etc/mtab", "r");
    if (file == NULL) {
        fprintf (stderr, "Cannot open /etc/mtab\n");
        return 1;
    }

    while ((entry = getmntent (file)) != NULL) {
        if (statvfs (entry->mnt_dir, &fs) == -1) {
            fprintf (stderr, "statvfs() error\n");
            return 1;
        }

        printf ("Filesystem: %s\n", entry->mnt_fsname);
        printf ("Mountpoint: %s\n", entry->mnt_dir);
        printf ("Block size: %ld\n", (unsigned long int)
            fs.f_bsize);
        printf ("Blocks: %ld\n", (unsigned long int)
            fs.f_blocks);
        printf ("Blocks free: %ld\n", (unsigned long int)
            fs.f_bfree);
        printf ("Blocks available: %ld\n",
            (unsigned long int) fs.f_bavail);
        printf ("Max. filename length: %ld\n",
            (unsigned long int) fs.f_namemax);
        printf ("Inodes: %ld\n",
            (unsigned long int) fs.f_files);
        printf ("Inodes free: %ld\n",
            (unsigned long int) fs.f_ffree);
        printf ("Inodes available: %ld\n",
            (unsigned long int) fs.f_favail);
        printf ("---\n");
    }
    
    endmntent (file);
    return 0;
}
```

Рассмотрим также программу stat1 (листинг 2.5). Структура `stat` содержит еще одно поле `st_ino`, в котором находится номер индексного узла, на который ссылается файл. 

Листинг 3.3 содержит дополненную версию программы stat1.

Листинг 3.3:
```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

int main (int argc, char ** argv)
{
    struct stat st;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (stat (argv[1], &st) == -1) {
        fprintf (stderr, "stat() error\n");
        return 1;
    }

    printf ("FILE:\t\t%s\n", argv[1]);
    printf ("UID:\t\t%d\n", (int) st.st_uid);
    printf ("GID:\t\t%d\n", (int) st.st_gid);
    printf ("SIZE:\t\t%ld\n", (long int) st.st_size);
    printf ("AT:\t\t%s", ctime (&st.st_atime));
    printf ("MT:\t\t%s", ctime (&st.st_mtime));
    printf ("INODE:\t\t%ld\n", (long int) st.st_ino);

    return 0;
}
```

Вернемся к программе `unlink1` (листинг 3.1). Теперь мы можем сказать, что системный вызов `unlink()` удаляет ссылку на индексный узел. Если эта ссылка была последней, то индекс освобождается. Рассмотрим еще один пример, демонстрирующий эту концепцию (листинг 3.4).

Листинг 3.4:

```cpp
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

#define HELLO_MSG "Hello World\n"

int main (int argc, char ** argv)
{
    int fd;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        fprintf (stderr, "Cannot open file "
            "(%s)\n", argv[1]);
        return 1;
    }
    
    if (unlink (argv[1]) == -1) {
        fprintf (stderr, "Cannot unlink file "
            "(%s)\n", argv[1]);
        return 1;
    }

    if (write (fd, HELLO_MSG, strlen (HELLO_MSG)) == -1) {
        fprintf (stderr, "write() error\n");
        return 1;
    }
    
    if (close (fd) == -1) {
        fprintf (stderr, "close() error\n");
        return 1;
    }
    
    return 0;
}
```
Вот что получилось после выполнения этого примера:
```
$ touch file1
$ ln file1 file2
$ ls -i file1 file2
1048740 file1 1048740 file2
$ ./unlink2 file1
$ ls file1
/bin/ls: file1: No such file or directory
$ cat file2
Hello World
```

Проведем еще один эксперимент:
```
$ ./unlink2 file2
$ ls file2
/bin/ls: file2: No such file or directory
```

Эта программа показывает, что над открытым файлом можно успешно осуществлять операции ввода-вывода, даже если последняя ссылка на этот файл удалена системным вызовом unlink().

#### Перемещение файлов

Системный вызов `rename()` позволяет переименовывать или перемещать файл в пределах одной файловой системы. В заголовочном файле stdio.h он объявлен следующим образом:
```cpp
int rename (const char * OLDF, const char * NEWF);
```

При успешном завершении `rename()` возвращает 0. В случае ошибки возвращается –1.

Следующий пример (листинг 3.5) демонстрирует работу системного вызова rename().

Листинг 3.5:
```cpp
#include <stdio.h>

int main (int argc, char ** argv)
{
    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (rename (argv[1], argv[2]) == -1) {
        fprintf (stderr, "rename() error\n");
        return 1;
    }
    
    return 0;
}
```

Посмотрим теперь, что будет делать `rename()`, если перемещаемый файл открыт. Для этого создадим еще одну программу (листинг 3.6).

Листинг 3.6:

```cpp
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

#define HELLO_MSG "Hello World\n"

int main (int argc, char ** argv)
{
    int fd;
    
    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        fprintf (stderr, "Cannot open file "
            "(%s)\n", argv[1]);
        return 1;
    }
    if (rename (argv[1], argv[2]) == -1) {
        fprintf (stderr, "rename() error\n");
        return 1;
    }

    if (write (fd, HELLO_MSG, strlen (HELLO_MSG)) == -1) {
        fprintf (stderr, "write() error\n");
        return 1;
    }
    
    close (fd);
    return 0;
}
```

Теперь проведем небольшой эксперимент:
```
$ touch file1
$ cat file1
$ ./rename2 file1 file2
$ ls file1
/bin/ls: file1: No such file or directory
$ cat file2
Hello World
```
Итак, мы убедились, что перемещение открытого файла никак не отражается на операциях ввода-вывода.

#### Создание ссылок: link()

Cсылки в файловой системе Linux бывают двух типов:
- символические ссылки (symbolic links);
- жесткие (прямые) ссылки (hard links).

Пользователь может создавать ссылки при помощи программы ln. А в распоряжении программиста имеются системные вызовы link() и symlink(). Первый создает прямые ссылки, второй — символические. Эти системные вызовы объявлены в заголовочном файле unistd.h следующим образом:

```cpp
int link (const char * FROM, const char * TO);
int symlink (const char * FROM, const char * TO);
```

Оба возвращают 0 при успешном завершении и –1, если произошла ошибка. Аргументы FROM (откуда) и TO (куда) аналогичны соответствующим свободным аргументам программы ln.

Следующая программа (листинг 3.7) показывает, как работает системный вызов `link()`.

Листинг 3.7:
```cpp
#include <unistd.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }
    
    if (link (argv[1], argv[2]) == -1) {
        fprintf (stderr, "link() error\n");
        return 1;
    }
    
    return 0;
}
```

Проверяем:
```
$ touch file1
$ ./linkdemo file1 file2
$ ls -i file1 file2
1048776 file1 1048776 file2
```

Теперь создадим еще одну программу (листинг 3.8), которая демонстрирует работу системного вызова `symlink()`.

Листинг 3.8:

```cpp
#include <unistd.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (symlink (argv[1], argv[2]) == -1) {
        fprintf (stderr, "link() error\n");
        return 1;
    }
    
    return 0;
}
```

Вот что получилось в результате:
```
$ touch file1
$ ./symlinkdemo file1 file2
$ ls -li file1 file2
1048779 -rw-r--r-- 1 nnivanov nnivanov 0 2011-05-07 10:03 file1
1048780 lrwxrwxrwx 1 nnivanov nnivanov 5 2011-05-07 10:03 file2 -> file1
```

#### Создание каталога: mkdir()

Для создания каталога используется системный вызов `mkdir()`, который объявлен в заголовочном файле sys/stat.h следующим образом:

```cpp
int mkdir (const char * NAME, mode_t MODE);
```
Системный вызов `mkdir()` создает каталог с именем NAME и режимом MODE. При успешном завершении `mkdir()` возвращает 0. В случае ошибки возвращается –1. Следующий пример (листинг 3.9) показывает, как работает системный вызов `mkdir()`.

Листинг 3.9:

```cpp
#include <stdio.h>
#include <sys/stat.h>

int main (int argc, char ** argv)
{
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (mkdir (argv[1], 0755) == -1) {
        fprintf (stderr, "mkdir() error\n");
        return 0;
    }
    
    return 0;
}
```

Приведенный пример — это упрощенная версия программы mkdir:
```
$ ./mkdir1 mydir
$ ls -l | grep mydir
drwx------ 2 nnivanov nnivanov 4096 2011-05-07 10:05 mydir
```

Рассмотрим еще один пример (листинг 3.10):

Листинг 3.10:

```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char ** argv)
{
    mode_t mode = 0777;
    
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (mkdir (argv[1], mode) == -1) {
        fprintf (stderr, "mkdir() error\n");
        return 0;
    }
    
    return 0;
}
```

Эта программа работает не так, как мы ожидали:
```
$ ./mkdir2 mydir
$ ls -l | grep mydir
drwxr-xr-x 2 nnivanov nnivanov 4096 2011-05-07 10:09 mydir
```

В системный вызов `mkdir()` передавался аргумент mode, в котором все биты базовых
прав доступа установлены в единицу. Но вывод программы ls показывает, что созданный каталог имеет права доступа 0755 (у вас может быть что-то другое). Давайте разберемся, почему так получилось.

К каждому процессу в Linux привязана маска прав доступа, которая наследуется потомком от родительского процесса (аналогично текущему каталогу, окружению и т. п.). Маска прав доступа — это число, представляющее собой набор битов прав доступа, которые никогда не будут устанавливаться для создаваемых процессом файлов или каталогов. Команда umask позволяет узнать текущую маску прав доступа командной оболочки:
```
$ umask
0022
```

Итак, маска прав доступа 0022 разрешает при создании файлов или каталогов устанавливать любые права доступа для владельца, но не разрешает права на запись для группы и остальных пользователей.

Текущий процесс вправе изменять свою копию маски прав доступа. Например, оболочка bash делает это при помощи той же самой команды umask:
```
$ umask 0044
$ umask
0044
```

Дочерние процессы наследуют копию маски прав доступа родительского процесса. Это легко проверить:
```
$ umask 000
$ umask
0000
$ bash
$ umask
0000
$ exit
exit
```

Давайте теперь вернемся к нашему примеру (листинг 3.10). Попробуем запустить программу mkdir2 с измененной маской прав доступа оболочки:
```
$ umask 0000
$ umask
0000
$ ./mkdir2 mydir
$ ls -l | grep mydir
drwxrwxrwx 2 nnivanov nnivanov 4096 2011-05-07 10:15 mydir
```

Программа может изменить маску прав доступа текущего процесса при помощи системного вызова umask(), который объявлен в заголовочном файле /sys/stat.h следующим образом:
```cpp
mode_t umask (mode_t MASK);
```

Этот системный вызов изменяет текущую маску прав доступа и возвращает предыдущее значение маски. Рассмотрим теперь пример использования системного вызова umask() для создания каталога с правами доступа 0777 (листинг 3.11).

Листинг 3.11:

```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char ** argv)
{
    mode_t mode = 0777;
    
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    umask (0000);
    
    if (mkdir (argv[1], mode) == -1) {
        fprintf (stderr, "mkdir() error\n");
        return 0;
    }
    
    return 0;
}
```

Вот что получилось в результате выполнения этого примера:
```
$ umask 0022
$ umask
0022
$ ./mkdir3 mydir
$ ls -l | grep mydir
drwxrwxrwx 2 nnivanov nnivanov 4096 2011-05-07 10:17 mydir
```

Обратите внимание, что в выводе команды ls для каталога mydir счетчик ссылок (второй столбец) равен 2. Эта вторая ссылка находится в самом каталоге mydir, обозначается точкой (.) и указывает на текущий каталог. 

Расширенные права доступа также могут использоваться при создании каталогов. Следующий пример (листинг 3.12) демонстрирует создание каталога с липким битом.

Листинг 3.12:

```cpp
#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

int main (int argc, char ** argv)
{
    mode_t mode = 0777 | S_ISVTX;
    
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    umask (0000);

    if (mkdir (argv[1], mode) == -1) {
        fprintf (stderr, "mkdir() error\n");
        return 0;
    }
    
    return 0;
}
```

Проверяем:
```
$ ./mkdir4 mydir
$ ls -l | grep mydir
drwxrwxrwt 2 nnivanov nnivanov 4096 2011-05-07 10:20 mydir
```

#### Удаление каталога: rmdir()

Для удаления каталога служит системный вызов `rmdir()`, который объявлен в заголовочном файле unistd.h следующим образом:

```cpp
int rmdir (const char * DIR);
```

При успешном завершении `rmdir()` возвращает 0. В случае ошибки возвращается –1.

Аргумент DIR — это имя (путь) к каталогу, который следует удалить. Следующий пример (листинг 3.13) демонстрирует работу системного вызова `rmdir()`.

```cpp
#include <stdio.h>
#include <unistd.h>

int main (int argc, char ** argv)
{
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (rmdir (argv[1]) == -1) {
        fprintf (stderr, "rmdir() error\n");
        return 1;
    }
    
    return 0;
}
```

Следует отметить, что системный вызов rmdir() удаляет только пустые каталоги.
Если каталог не пуст, то rmdir() завершится неудачей. Проверим это:

```
$ mkdir mydir
$ touch mydir/myfile
$ ./rmdirdemo mydir
rmdir() error
$ rm mydir/myfile
$ ./rmdirdemo mydir
$ ls mydir
/bin/ls: mydir: No such file or directory
```