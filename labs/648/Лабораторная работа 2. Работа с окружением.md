# Лабораторная работа №2. Операционные системы и системное программное обеспечение

Целью работы является знакомство с механизмами, позволяющими программам читать 
и модифицировать окружение.

## 1. ПОНЯТИЕ ОКРУЖЕНИЯ

В основе многозадачности лежит понятие "процесс". Процесс — это нечто, совершающее в системе какие-либо действия. Обычно это запущенная работающая программа. Один процесс может инициировать (породить) другой. 

В таком случае породивший процесс называют родителем или родительским процессом, а порожденный — потомком или дочерним процессом. 

Все процессы в системе — элементы одной иерархии, называемой деревом процессов. На вершине этой иерархии находится процесс init. Это единственный процесс, не имеющий родителя. Каждый раз, когда вы запускаете в командной строке какую-нибудь программу, например ls, в системе рождается новый процесс, для которого командная 
оболочка является родителем.

Окружение (environment) — это набор специфичных для конкретного пользователя пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ . Каждый процесс располагает и свободно распоряжается своей копией окружения, которую он получает от родителя. Таким образом, если процесс сначала модифицирует свое окружение, а потом породит новый процесс, то потомок 
получит копию уже измененного окружения.

Чтобы посмотреть, что представляет собой окружение в действительности, введите следующую команду:
`$ env`

На экран будет выведено окружение программы env. Можете не сомневаться, это точная копия окружения вашей командной оболочки. В современных Linux-дистрибутивах окружение представлено десятками переменных, но широко используются только некоторые из них:
- USER - имя пользователя;
- HOME - домашний каталог;
- PATH - список каталогов, в которых осуществляется поиск исполняемых файлов программ;
- SHELL - используемая командная оболочка;
- PWD — текущий каталог.

Следующий шаблон позволяет посмотреть значение конкретной переменной:
`$ echo $VARIABLE`

Здесь  VARIABLE — это имя переменной. Вообще говоря, оболочка вместо записи $VARIABLE всегда подставляет значение соответствующей переменной окружения. Рассмотрим пример:
`$ touch $USER`

Вместо  $USER здесь подставляется значение переменной. Такая команда создаст пустой файл, присвоив ему имя текущего пользователя.

Пользователь может модифицировать окружение командной оболочки. В разных оболочках это делается по-разному. Рассмотрим такую возможность на примере bash. 

Эта оболочка, помимо свойственного любому процессу окружения, поддерживает также свой собственный набор переменных, которые называют локальными переменными оболочки. Рассмотрим пример:
```
$ MYVAR=Hello
$ echo $MYVAR
$ env | grep MYVAR
$
```

Первой командой создается и инициализируется локальная переменная оболочки MYVAR. Следующая команда выводит значение этой переменной. Третья команда ищет переменную  MYVAR среди окружения программы env (точная копия окружения оболочки). Но поскольку  MYVAR не является переменной окружения, то последняя команда ничего не выводит. Как видно из этого примера, локальные переменные "работают" только на уровне оболочки. Не являясь частью окружения, они не могут наследоваться дочерними процессами. Поэтому программа env не нашла переменную  MYVAR . Но иногда требуется включить (экспортировать) локальную переменную в окружение. Для этого в оболочке bash есть внутренняя (не являющаяся отдельной программой) команда export:
```
$ export MYVAR
$ env | grep MYVAR
MYVAR=Hello
```

Команду  export можно также использовать для инициализации и экспорта переменной в один прием:
```
$ export MYVAR_NEW=Goodbye
$ env | grep MYVAR_NEW
MYVAR_NEW=Goodbye
```

Важно понимать, что полученные переменные  MYVAR и  MYVAR_NEW существуют только в текущем окружении процесса оболочки и ее потомков. Очевидно, что после перезагрузки эти переменные "исчезнут", если их, например, не объявить в файле инициализации bash. Даже такая жизненно важная переменная, как  PATH , не появляется в окружении оболочки сама собой: строка для ее инициализации обычно находится в файле /etc/profile. Исключить переменную из окружения оболочки позволяет команда  export -n . При этом остается локальная переменная. Когда же надо удалить переменную отовсюду, вызывают команду  unset:
```
$ env | grep -i myvar
MYVAR_NEW=Goodbye
MYVAR=Hello
$ export -n MYVAR
$ env | grep MYVAR
MYVAR_NEW=Goodbye
$ echo $MYVAR
Hello
$ unset MYVAR_NEW
$ env | grep MYVAR
$ echo -n $MYVAR_NEW
$
```

Важно понимать, что  export ,  export -n и  unset — это не отдельные программы, а внутренние команды bash. Оболочки ksh (KornShell) и zsh (Z shell), например, не поддерживают опцию  -n команды  export . Оболочки семейства C-Shell (csh, tcsh) работают с окружением совсем другими командами  setenv и  unsetenv.

## 2. ЧТЕНИЕ ОКРУЖЕНИЯ

Программа может читать окружение двумя способами:
1. Посредством внешней переменной  environ , представляющей собой массив строк ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ . Эта переменная объявлена в заголовочном файле unistd.h.
2. При помощи функции  getenv() , которая возвращает значение указанной переменной окружения. Эта функция объявлена в заголовочном файле stdlib.h.

Функция  getenv() имеет следующий прототип:
`char * getenv (char * VAR_NAME);`

Она возвращает значение указанной переменной VAR_NAME. Если переменная отсутствует в окружении, то возвращается  NULL.

Рассмотрим сначала пример, использующий `environ` . Следующая программа (листинг 1) просто выводит на экран свое окружение.

Листинг 1:
```cpp
#include <stdio.h>
#include <unistd.h>
extern char ** environ;
int main (void)
{
    int i;
    for (i = 0; environ[i] != NULL; i++)
        printf ("%s\n", environ[i]);
    return 0;
}
```

Массив `environ` обычно используется для просмотра окружения (как в нашем случае), а также для передачи окружения в другой процесс в ходе реализации многозадачности. Для получения значения конкретной переменной предназначена функция  `getenv()`. Приведенная в листинге 2 программа демонстрирует ее работу.

Листиниг 2:
```cpp
#include <stdio.h>

int main (int argc, char ** argv)
{
    char * value;
    if (argc < 2) {
        fprintf (stderr, "Usage: myenv2 <variable>\n");
        return 1;
    }

    value = (char*) getenv (argv[1]);

    if (value == NULL)
        printf ("%s not found\n", argv[1]);
    else
        printf ("%s=%s\n", argv[1], value);

    return 0;
}
```

Программа выводит значение переменной окружения, имя которой читается из первого аргумента командной строки (`argv[1]`). Функция  `getenv()` возвращает значение  NULL, если переменная окружения не найдена. В этом случае наша программа выводит соответствующее сообщение:
```
$ gcc -o myenv1 myenv1.c
$ ./myenv1 ABRAKADABRA
ABRAKADABRA not found
$ ./myenv1 USER
USER=nnivanov
$ ./myenv1 user
user not found
```

Обратите внимание, что имена переменных окружения чувствительны к регистру символов. Исторически сложилась практика именования переменных окружения заглавными буквами, однако символы нижнего регистра также допускаются. Действительно, запись "user not found" выглядит несколько двусмысленно: то ли переменная  user не найдена, 
то ли пользователь не найден. А все из-за того, что имя переменной сливается с остальным текстом.

## 3. МОДИФИКАЦИЯ ОКРУЖЕНИЯ

Чаще всего модификация окружения требуется при реализации многозадачности. Дочерний процесс получает копию окружения своего родителя. 

Приведем пример. Некоторые программы читают языковую информацию (локаль) из переменной окружения  LANG . Этим можно воспользоваться. Если текущая локаль настроена на русский язык, то программа date, например, будет выводить примерно следующее:
```
$ date
Птн Апр 29 06:48:00 MSD 2011
```

Однако если изменить переменную окружения  LANG , то программа date унаследует ее от оболочки. Можно, например, вывести дату на английском, французском или даже на финском языке:
```
$ export LANG=en_US
$ date
Fri Apr 29 06:48:47 MSD 2011
$ export LANG=fr_FR
$ date
ven. avril 29 06:52:16 MSD 2011
$ export LANG=fi_FI
$ date
pe 29.4.2011 06.52.38 +0400
```

Такие "трюки" возможны не везде, а лишь в версиях Linux с языковой поддержкой. Но смысл в том, что дочернему процессу можно "подсунуть" любое окружение. Для этого даже не обязательно менять окружение оболочки. Передать программе модифицированное окружение можно при помощи уже знакомой нам программы env:
```
$ env LANG=fi_FI date
pe 29.4.2011 06.53.30 +0400
```

На практике модификация окружения осуществляется функциями `setenv()`, `putenv()` и `unsetenv()`, которые объявлены в заголовочном файле stdlib.h.
`int setenv (const char * NAME, const char * VALUE, int OV);`

Функция `setenv()` добавляет новую или изменяет существующую переменную окружения с именем `NAME`, присваивая ей значение `VALUE`. 

- OV — это флаг перезаписи, показывающий, нужно ли перезаписывать переменную, если таковая 
существует. Если параметр OV не равен нулю, то переменная перезаписывается, в противном 
случае переменная остается нетронутой.  
- setenv() возвращает 0 при успешном завершении и –1, если произошла ошибка.

`int putenv (char * INITSTR);`

Функция `putenv()` добавляет новую или заменяет существующую переменную окружения, используя строку инициализации `INITSTR` в формате  ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ. `putenv()` возвращает 0 при успешном завершении и –1, если произошла ошибка. Следует отметить, что функция  `putenv()` реализована не во всех Unix-подобных системах, 
что может сказаться на переносимости.

`int unsetenv (const char * NAME);`

Функция `unsetenv()` удаляет переменную с именем  NAME из окружения. Ранее функция `unsetenv()` ничего не возвращала, и лишь в glibc-2.2.2 все изменилось. В настоящее время `unsetenv()` возвращает 0 при успешном завершении или –1 — в случае ошибки.

Рассмотрим сначала пример, демонстрирующий работу функции `setenv()` (листинг 3).

Листинг 3. Пример setenvdemo.c
```cpp
#include <stdlib.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
    int ov_flag = 1;
    char * var;
    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }
    
    setenv (argv[1], argv[2], ov_flag);
    var = getenv (argv[1]);
    if (var == NULL)
        printf ("Variable %s doesn't exist\n", argv[1]);
    else
        printf ("%s=%s\n", argv[1], var);
    
    return 0;
}
```

Приведенная программа читает два аргумента командной строки: имя переменной и ее значение. Особый интерес представляет переменная  ov_flag . Если присвоить ей нулевое значение, то поведение программы изменится: функция  setenv() не будет перезаписывать уже существующие переменные окружения, унаследованные от командной оболочки.

Рассмотрим теперь пример использования `putenv()` (листинг 4).

Листинг 4. Пример putenvdemo.c

```cpp
#include <stdlib.h>
#include <stdio.h>

int main (int argc, char ** argv)
{
    char * var;
    char initvar[1024];
 
   if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    sprintf (initvar, "%s=%s", argv[1], argv[2]);
    putenv (initvar);

    var = getenv (argv[1]);

    if (var == NULL)
        printf ("Variable %s doesn't exist\n", argv[1]);
    else
        printf ("%s=%s\n", argv[1], var); 

    return 0;
}
```

Эта программа работает так же, как и setenvdemo (листинг 3) с установленным флагом перезаписи. Очевидно, что в ситуациях, когда имя переменной окружения и ее значение хранятся в разных строках, всегда целесообразнее использовать `setenv()`.

Теперь рассмотрим программу, работающую с функцией `unsetenv()` (листинг 5).

Листинг 5. Программа unsetenvdemo.c

```cpp
#include <stdlib.h>
#include <stdio.h>

extern char ** environ;

int main (int argc, char ** argv)
{
    int i;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    if (unsetenv (argv[1]) != 0) {
        fprintf (stderr, "Cannot unset %s\n", argv[1]);
        return 1;
    }

    for (i = 0; environ[i] != NULL; i++)
        printf ("%s\n", environ[i]);

    return 0;
}
```

Эта программа удаляет из окружения переменную, переданную в качестве аргумента, а затем выводит на экран все окружение, через механизм просмотра массива environ. Таким образом можно убедиться, что переменная действительно удалена из окружения:
```
$ ./unsetenvdemo USER | grep USER
$
```

Обратите внимание, что передача в функцию `unsetenv()` имени несуществующей переменной не считается ошибкой. Это говорит о том, что `unsetenv()` не обязуется, а только пытается удалить переменную из окружения. Другое дело, когда в имя переменной "вкрадывается", например, знак равенства:
`$ ./unsetenvdemo USER=`

В результате будет выдано сообщение
`Cannot unset USER= `

Поскольку знак равенства является служебным символом, функция `unsetenv()` выдала ошибку.

## 4. ОЧИСТКА ОКРУЖЕНИЯ

Есть два способа очистить окружение процесса:
1. Присвоить массиву  environ значение  NULL.
2. Воспользоваться функцией  clearenv().

Функция `clearenv()` объявлена в заголовочном файле `stdlib.h` следующим образом:
`int clearenv (void);`

В обычных приложениях, не требующих повышенных мер безопасности, целесообразнее выбрать первый способ, поскольку функция `clearenv()` реализована не во всех Unix-подобных системах.

В тех случаях, когда необходимо предотвратить возможность доступа к окружению потенциальных злоумышленников (в серверах, браузерах, сетевых приложениях и т. д.), используют функцию  clearenv() . Дело в том, что присвоение массиву environ значения NULL лишь ликвидирует указатель. При этом бывшее окружение остается в памяти процесса. 
Функция clearenv() освобождает память, делая бывшее окружение практически недоступным.
