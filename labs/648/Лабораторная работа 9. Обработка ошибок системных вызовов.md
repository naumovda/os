# Лабораторная работа №9. Обработка ошибок системных вызово

## Методические материалы

В этой работе будут рассмотрены следующие темы:
- Классификация ошибок.
- Общие правила вывода сообщений об ошибках.
- Использование макроса assert() для защиты от случайных ошибок.
- Ошибки системных вызовов.

### 1. Типы ошибок

Существуют различные классификации ошибок, которые могут появляться в программах. Обычно ошибки делят на следующие типы:
- ошибки входных данных;
- непредвиденные ошибки;
- скрытые ошибки;
- унаследованные ошибки.

Ошибки входных данных — это нормальная ситуация, когда программа получает от пользователя то, что не может быть адекватно обработано. Основная проблема здесь заключается именно в выявлении ошибки: программист должен предусмотреть все возможные варианты. Но это теория, на практике все обстоит иначе. Например, если программа принимает от пользователя только два символа (char), то число возможных комбинаций входных данных составляет 65536.
Если программа заранее не выявила ошибку входных данных, то это может сказаться на безопасности. Злоумышленник может подобрать такие входные данные, которые способны значительно изменить поведение программы. Обычно такие ошибки устраняются по мере их появления.
Иногда даже те программы, которые мы считаем абсолютно надежными и проверенными, начинают вести себя неадекватно при работе с некоторыми входными данными. Рассмотрим небольшой пример из серии первоапрельских розыгрышей (листинг 1.1).

Листинг `.1. Пример joke1.c
```cpp
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main (void)
{
    int fd = creat ("--version", 0640);

    if (fd == -1) {
        fprintf (stderr, "creat() error\n");
        return 1;
    }
    
    close (fd);
    return 0;
}
```
Итак, проверяем:
```
$ gcc -o joke1 joke1.c
$ ./joke1
$ ls
joke1 joke1.c --version
```

В текущем каталоге появился файл --version. Попробуйте теперь удалить этот файл при помощи программы rm в оболочке bash:
```
$ rm --version
rm (GNU coreutils) 8.5
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Written by Paul Rubin, David MacKenzie, Richard M. Stallman,
and Jim Meyering.
$ ls
joke1 joke1.c --version
```

Не помогают даже кавычки и шаблоны wildcard:
```
$ rm "--version"
rm (GNU coreutils) 8.5
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Written by Paul Rubin, David MacKenzie, Richard M. Stallman,
and Jim Meyering.
$ rm *version
rm (GNU coreutils) 8.5
Copyright (C) 2010 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Written by Paul Rubin, David MacKenzie, Richard M. Stallman,
and Jim Meyering.
$ ls
joke1 joke1.c --version
```

Это просто невинная шутка. Но подумайте, что будет, если имя файла содержит что-нибудь наподобие $HOME. Не экспериментируйте! 

Но здесь важно понимать, что если программа будет слишком "усердно" проверять входные данные, то это наверняка скажется на производительности. Поэтому иногда стоит просто отказаться от проверки в угоду скорости, если не возникает явных проблем с безопасностью.

Непредвиденные ошибки возникают тогда, когда программа попадает в экстремальные cитуации: нехватка памяти, мало свободного места на диске и т. д. Следует понимать, что такие ошибки являются штатными, и программа должна быть готовой к их появлению. Есть несколько общих правил, которые позволяют избежать многих непредвиденных ошибок.
- Всегда проверяйте результат выделения динамической памяти.
- Проверяйте файловые дескрипторы после операций open(), creat(), socket() и т. п.
- Проверяйте результат выполнения системных вызовов, включая close().
- Проверяйте argc перед использованием argv.
- Проверяйте указатели, полученные от других функций.

Некоторые ситуации сложно воспроизвести при тестировании. Но, например, нехватку дискового пространства можно симулировать при помощи специального устройства /dev/full. Для проверки работы программы с большими файлами можно использовать /dev/zero.
Если непредвиденные ошибки можно сравнить с "неисправным огнетушителем", то скрытые ошибки больше напоминают "пехотные мины": наступить на нее — дело случая. Вот распространенный пример такой ошибки:
```cpp
s = (char*) malloc (BUF_SIZE);
...
count = read (fd, s, BUF_SIZE);
s [count] = '\0';
```

Итак, сначала в программе выделяется динамическая память размером `BUF_SIZE`, и адрес заносится в указатель `s`. Затем системный вызов `read()` читает не более чем BUF_SIZE байтов из некоторого файла и заносит данные в память, обозначенную указателем `s`. 

Следующая строка — это и есть скрытая ошибка. Когда вызов `read()` прочитает `BUF_SIZE` байтов, нуль-терминатор будет занесен в элемент s[BUF_SIZE], т. е. за пределы выделенной памяти. Эта программа может работать без сбоев несколько лет. Но ничто не помешает ей "рухнуть" в самый ответственный момент.

Унаследованные ошибки появляются в программах из библиотек или даже из ядра ОС. Эти ошибки обычно исчезают после исправления библиотеки. Но здесь есть один побочный эффект. Часто бывает, что динамическая библиотека содержит ошибку, а программист пренебрегает документацией и добивается корректной работы своей программы "методом научного тыка", используя заведомо неправильное поведение библиотеки. Когда появляется исправленная версия библиотеки, то уже сама программа перестает работать правильно. Чтобы избежать подобного, не стоит "выбивать" из программ правильное поведение. Работа любой сторонней функции должна быть вам понятна.

### 2. Сообщения об ошибках

В зависимости от типа ошибки программой могут выводиться различные сообщения. Ошибки входных данных — это штатная ситуация, подразумевающая диалог с пользователем. Например, если пользователь передал в программу имя несуществующего файла, достаточно просто сказать "файл не существует" и указать имя этого файла.

Непредвиденные ошибки могут быть фатальными и обрабатываемыми. Фатальные ошибки возникают тогда, когда программа не может справиться с возникшей ситуацией. В подавляющем большинстве случаев эти ошибки заканчиваются завершением программы. Идеальный вариант сообщения о фатальной ошибке — вывести отладочную информацию и предложить пользователю отправить эту информацию разработчикам программы. 

Обрабатываемые сообщения об ошибках обычно подразумевают продолжение работы программы. В этом случае пользователю выводится сообщение о том, что операция не удалась. Скрытые ошибки оправдывают свое название. Наиболее приемлемый способ защититься от них — использовать макрос `assert()`, который позволяет контролировать правильность выполнения программы в различных ее местах. Если что-то пошло не так, как было задумано, `assert()` завершает программу и выводит информацию о "нарушении". При помощи `assert()` можно защититься и от унаследованных ошибок.

Важно понимать, что при возникновении любой ошибки программа не должна "молчать". Если ошибка не связана напрямую с входными данными и подразумевает завершение программы, то лучше вывести как можно больше информации в надежде на то, что пользователь предоставит эту информацию разработчикам.

### 3. Макрос assert()

Макрос `assert()` — это простой, но очень эффективный способ защиты от скрытых и наследуемых ошибок. `assert()` объявлен в заголовочном файле assert.h следующим образом:
```cpp
void assert (EXPRESSION);
```

Единственный аргумент `EXPRESSION` — это логическое выражение. 

Макрос assert() работает очень просто: если выражение `EXPRESSION` ложное, то программа аварийно завершается с выводом соответствующего сообщения.

Нужно понимать, что `assert()` — это не упрощенный способ вывода пользователю сообщений об ошибках. В качестве `EXPRESSION` должно фигурировать выражение, которое является истинным по определению. Например, перед использованием массива полезно будет выполнить такую проверку:
```cpp
assert (array != NULL);
array_sort (array);
```

Но следующая запись говорит о дурном стиле программирования:
```cpp
array = (char *) malloc (ARR_SIZE);
assert (array != NULL);
```

А эта запись вообще никуда не годится:
```cpp
int fd = open (FILENAME, O_RDONLY);
assert (fd != -1);
```
В двух последних случаях выражение внутри `assert()` вовсе не обязано быть истинным по определению. Функция `malloc()` может вернуть нулевой указатель, если исчерпана свободная память, а отсутствие открываемого файла (второй случай) — обычное дело.
Рассмотрим пример (листинг 3.1), который демонстрирует работу макроса assert().

Листинг 3.1. Пример assert1.c
```cpp
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

int main (int argc, char ** argv)
{
    int month;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    month = atoi (argv[1]);

    assert ((month >= 1) && (month <= 12));

    return 0;
}
```
Добавим заодно к программе make-файл (листинг 3.2), который нам понадобится в дальнейшем.

Листинг 3.2. Файл Makefile
```
FLAGS=
assert1: assert1.c
gcc $(FLAGS) -o $@ $^
clean:
rm -f assert1
```

Итак, данная программа получает от пользователя календарный месяц в виде числа. Предположим, что проверка вхождения этого значения в диапазоне от 1 до 12 уже выполнена. В каком-то месте программы появляется макрос assert(), чтобы подтвердить нормальный ход программы. В нашей программе нет реальной проверки входных данных, поэтому мы легко сможем увидеть действие `assert()`:
```
$ make
gcc -o assert1 assert1.c
$ ./assert1 10
$ ./assert1 13
assert1: assert1.c:15: main: Assertion `(month >= 1) &&
(month <= 12)' failed.
Aborted
```

Макрос `assert()` обладает еще одной полезной особенностью. Если скомпилировать программу с включением макроконстанты `NDEBUG`, то все вхождения `assert()` исчезнут. 

Если в программе `assert()` встречается часто, то применение NDEBUG может "одним махом" увеличить производительность приложения, а также уменьшить размер исполняемого кода. Обычно это делается тогда, когда программа завершает тестирование и выпускается для официального использования.

Макроконстанту `NDEBUG` можно включить непосредственно в программу:
```cpp
#define NDEBUG
```

В этом случае программист может устанавливать политику использования `assert()` для каждого исходного файла в отдельности. Но это требует изменения исходного кода программы, что не всегда приемлемо.

Можно объявить `NDEBUG` на стадии компиляции через аргумент -D компилятора gcc.
Наш make-файл содержит константу FLAGS, которую можно указать прямо во время вызова make.

Вот как это делается:
```
$ make clean
rm -f assert1
$ make FLAGS=-DNDEBUG
gcc -DNDEBUG -o assert1 assert1.c
$ ./assert1 15
$
```

Рассмотрим еще один немного странный, но показательный пример (листинг 3.3).

Листинг 3.3. Пример assert2.c
```cpp
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#define FAIL_SUM 10

int myfunc (int a, int b)
{
    printf ("Hello\n");
    return (a + b);
}

int main (int argc, char ** argv)
{
    int a, b;

    if (argc < 3) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    a = atoi (argv[1]);
    b = atoi (argv[2]);
    
    assert (myfunc (a, b) != FAIL_SUM);

    return 0;
}
```

Эта программа принимает два аргумента, переводит их в числовое значение, а потом сравнивает сумму этих чисел со значением `FAIL_SUM`. Предполагается, что введенные числа в сумме не должны давать `FAIL_SUM`. 

Функция `myfunc()` выводит на экран сообщение `"Hello"` и возвращает сумму введенных пользователем чисел. Затем макрос `assert()` проверяет возвращенное функцией `myfunc()` значение на равенство `FAIL_SUM`. Все довольно просто и работает без нареканий:
```
$ gcc -o assert2 assert2.c
$ ./assert2 7 4
Hello
$ ./assert2 7 3
Hello
assert2: assert2.c:24: main: Assertion
'myfunc (a, b) != 10' failed.
Aborted
```

Но все изменится, если мы соберем программу с макроконстантой `NDEBUG`:
```
$ gcc -DNDEBUG -o assert1 assert1.c
$ ./assert1 7 4
$ ./assert1 7 3
```

Отключение вхождений `assert()` привело к тому, что функция `myfunc()` теперь вообще не вызывается. Поэтому не нужно забывать, что `assert()` является отключаемым макросом, а не функцией.

### 4. Чтение ошибки: errno
В случае ошибки системные вызовы обычно возвращают –1.  Примеры, которые рассматривались, просто констатировали факт ошибочного завершения системных вызовов и завершались с ненулевым кодом возврата. Однако в Linux есть средства, позволяющие конкретизировать ошибки системных вызовов и обрабатывать их.

Рассмотрим системный вызов `open()`. В случае ошибки он возвращает –1. Но этого часто бывает недостаточно даже для вывода конкретного сообщения об ошибке. Например, ошибка `open()` может означать отсутствие файла, отсутствие прав доступа или еще что-нибудь. Для диагностики ошибок всех системных вызовов предусмотрена внешняя переменная errno, которая объявлена в заголовочном файле `errno.h` следующим образом:
```cpp
extern int errno;
```

Механизм работает очень просто: если какой-нибудь системный вызов завершился с ошибкой, то код ошибки заносится в `errno`. Но здесь надо учитывать, что каждый ошибочный системный вызов перезаписывает общую для всех в контексте одной программы переменную errno. Это зачастую требует своевременного сохранения значения `errno` в другой переменной.

Вот наиболее распространенный пример неправильного использования `errno`:
```cpp
if (write (fd, buf, buf_size) == -1) {
    fprintf (stderr, "write() problem:\n");
    if (errno == EBADF) {
        ...
    }
...
}
```

Это скрытая ошибка, которая может проявиться не сразу. Действительно, вывод сообщения в поток ошибок stderr редко заканчивается ошибкой. Но мы должны помнить, что функция `fprintf()` работает с системными вызовами. Если один из этих системных вызовов завершится неудачей, то значение `errno` будет перезаписано и обработка исходной ошибки будет неправильной. 

Вот еще одна ошибка такого рода:
```cpp
if (write (fd, buf, buf_size) == -1) {
    switch (errno) {
    ...
    }
}
```

Коды ошибок системных вызовов обозначаются символическими константами, которые становятся доступными при включении в программу заголовочного файла `errno.h`. Каждый системный вызов располагает собственным набором таких констант. В приложении приведен список этих констант с описаниями для каждого системного вызова.

Рассмотрим теперь пример обработки ошибок системных вызовов с использованием `errno`:
Листинг 4.1. Программа errno1.c
```cpp
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

int main (int argc, char ** argv)
{
    int fd, errno_local;
    
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_RDWR, 0600);
    if (fd == -1) {
        errno_local = errno;
        switch (errno_local)
        {
            case (ENOENT):
                printf ("not exist\n");
                return 1;
            case (EISDIR):
                printf ("is a directory\n");
                return 1;
            case (EACCES):
                printf ("access denied\n");
                return 1;
            default:
                printf ("unknown error\n");
                return 1;
        }
    }
    close (fd);
    return 0;
}
```

Вот как работает эта программа:
```
$ gcc -o errno1 errno1.c
$ ./errno1 myfile
not exist
$ mkdir myfile
$ ./errno1 myfile
is a directory
$ rmdir myfile
$ touch myfile
$ ./errno1 myfile
$ chmod 000 myfile
$ ./errno1 myfile
access denied
```

Обратите внимание, что перед обработкой значение errno сохраняется в отдельной переменной `errno_local`.

### 5. Сообщение об ошибке: strerror(), perror()

Для преобразования `errno` в сообщение об ошибке служит функция `strerror()`, которая объявлена в заголовочном файле string.h следующим образом:
```cpp
char * strerror (int ERRN);
```

Функция возвращает строку — сообщение об ошибке, соответствующее коду `ERRN`, полученному из `errno`. Данная функция не предполагает ошибочного завершения. 

Следующий пример (листинг 5.1) демонстрирует работу функции `strerror()`:

Листинг 5.1. Программа errno2.c
```cpp
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main (int argc, char ** argv)
{
    int fd, errno_local;
    
    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_RDWR, 0600);
    if (fd == -1) {
        fprintf (stderr, "%s\n", strerror (errno));
        return 1;
    }

    close (fd);
    return 0;
}
```

Проверяем:
```
$ gcc -o errno2 errno2.c
$ ./errno2 myfile
No such file or directory
$ mkdir myfile
$ ./errno2 myfile
Is a directory
$ rmdir myfile
$ touch myfile
$ ./errno2 myfile
$ chmod 000 myfile
$ ./errno2 myfile
Permission denied
```

Для совсем "ленивых" программистов существует функция `perror()`, которая самостоятельно читает значение errno и выводит сообщение об ошибке в стандартный поток ошибок. Эта функция объявлена в заголовочном файле `stdio.h` следующим образом:
```cpp
void perror (const char * PREFIX);
```

Здесь `PREFIX` — это произвольная строка, которая выводится перед сообщением об ошибке. Между этой строкой и сообщением `perror()` автоматически вставляет двоеточие и пробел. Обычно в качестве `PREFIX` указывается имя программы или системного вызова.

Не стоит пренебрегать префиксами в сообщениях об ошибках. Если две программы разделяют один поток ошибок, то использование префиксов подчас бывает единственным способом отличить сообщения об ошибках, сделанные разными программами.

Следующий пример (листинг 5.2) демонстрирует использование функции `perror()`.

Листинг 5.2. Программа errno3.c
```cpp
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>

int main (int argc, char ** argv)
{
    int fd, errno_local;

    if (argc < 2) {
        fprintf (stderr, "Too few arguments\n");
        return 1;
    }

    fd = open (argv[1], O_RDWR, 0600);
    if (fd == -1) {
        perror ("open");
        return 1;
    }

    close (fd);
    return 0;
}
```

Вот как работает эта программа:
```
$ gcc -o errno3 errno3.c
$ ./errno3 myfile
open: No such file or directory
$ mkdir myfile
$ ./errno3 myfile
open: Is a directory
$ rmdir myfile
$ touch myfile
$ ./errno3 myfile
$ chmod 000 myfile
$ ./errno3 myfile
open: Permission denied
```
