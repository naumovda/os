# Лабораторная работа №4. Аргументы и опции программы

Целью работы является изучение механизма опций, который значительно облегчает понимание 
смысла передаваемых в программу аргументов.

## 1. АРГУМЕНТЫ ПРОГРАММЫ

Программа, созданная на языке C, может получать данные извне посредством чтения аргументов функции `main()`. Такие данные называют аргументами программы.

Не следует отождествлять понятия "аргументы программы" и "аргументы командной строки". Дело в том, что программа получает свои аргументы от родительского процесса, в качестве которого не всегда выступает командная оболочка. Таким процессом может оказаться, например, браузер, в котором никакой "командной строки" нет.

Прототип (объявление) функции  main() можно представить следующим образом:
`int main (int argc, char ** argv, char ** envp)`

Третий аргумент, идентичный массиву `environ` и содержащий окружение программы, исторически не прижился. Поэтому функцию `main()` обычно представляют в укороченном виде:
`int main (int argc, char ** argv)`

Если в программе не предусмотрено чтение аргументов, то функцию `main()` можно объявить еще проще:
`int main (void)`

или даже так:
`int main ()`

Возможность подобных вариаций с прототипами обусловлена отсутствием единого объявления для функции `main()`. Работая с ее аргументами, компилятор рассчитывает лишь на "здравый рассудок" программиста.

Значение  argc показывает общее число аргументов программы. Всегда следует помнить, что первый аргумент ( argv[0] ) формально содержит имя программы. Реально в  argv[0] может находиться что угодно.

Вместо "исторических" имен `argc` и `argv` можно выбрать любые другие. В этом можно легко убедиться, написав небольшую программу (листинг 1). Но имена `argc` и  `argv` настолько укоренились в культуре программирования, что любой опытный программист наверняка скажет, что приведенный в листинге 1 пример написан в дурном стиле.

Листинг 1. Программа mainargs.c
```cpp
#include <stdio.h>

int main (int a, char ** b)
{
    int i;
    for (i = 0; i < a; i++)
        printf ("%d: %s\n", i, b[i]);
    return 0;
}
```

Аргументы программы могут интерпретироваться как угодно. Но это, как ни странно, может создавать большие неудобства. Если каждая программа ведет себя по-своему, то работа пользователя может превратиться в кошмар. Чтобы избежать подобных ситуаций, подавляющее большинство программ в Linux используют опции.

Опции (options) — это унифицированный интерфейс для передачи данных в программу через аргументы. Механизм опций позволяет разделить все аргументы программы на следующие категории:
- Опции. Обычно перед опцией стоит дефис. Различают короткие (односимвольные) и длинные (многосимвольные) опции. Длинные опции часто начинаются с последовательности из двух дефисов.
- Зависимые аргументы (аргументы опций). Некоторые опции предполагают наличие аргумента. Например, имя файла, которое указывается вслед за опцией  -o компилятора gcc, является зависимым аргументом. Опции, не требующие наличия зависимых аргументов, называют флагами (flags). Как правило, одна опция может принимать только один такой аргумент.
- Свободные аргументы. Эти аргументы не связаны напрямую с опциями. Например, имя каталога, передаваемое программе rmdir, является свободным аргументом.

Рассмотрим пример вызова программы с использованием опций:
`$ gcc -pedantic -c -o program.o program.c`

Итак, команда состоит из шести частей.
1. gcc — это имя программы, которое командная оболочка обычно заносит в argv[0] .
2. -pedantic — длинная опция, не требующая наличия зависимого аргумента (флаг).
3. -c — короткая опция, не требующая наличия свободного аргумента (флаг).
4. -o — короткая опция, требующая наличия зависимого аргумента.
5. program.o — это зависимый аргумент опции  -o .
6. program.c — свободный аргумент.

## 2. ИСПОЛЬЗОВАНИЕ ОПЦИЙ

Чтобы использовать опции, не обязательно выполнять самостоятельный синтаксический разбор аргументов программы. В этом разделе будут описаны средства обработки односимвольных (коротких) опций при помощи функции `getopt()`.

Функция `getopt()` объявлена в заголовочном файле `getopt.h` следующим образом:
`int getopt (int ARGC, char ** ARGV, const char * OPTS)`

- ARGC и  ARGV — это знакомые нам аргументы функции  main(). 
- В строке  OPTS перечислены опции (без разделителей и дефисов), используемые программой. Если после имени следует двоеточие, это означает, что опция требует наличия зависимого аргумента. Например, если  
OPTS указывает на строку  a:bc, то программа принимает три опции:  -a ,  -b и  -c , 
причем  -a подразумевает наличие зависимого аргумента, а опции  -b и  -c являются флагами.

Обработка опций программы подразумевает неоднократный вызов функции `getopt()`, которая возвращает код очередной фактически переданной опции. Если пользователь ввел опцию, не указанную в строке  OPTS , то  getopt() возвращает код символа "?" (знак вопроса). Когда все имеющиеся опции обработаны,  getopt() возвращает –1.

Для чтения аргументов опций и независимых аргументов предназначены следующие внешние переменные, также объявленные в файле getopt.h:
```cpp
extern char * optarg;
extern int optind;
```

Строка optarg содержит зависимый аргумент обрабатываемой опции, а в переменной  optind хранится индекс первого свободного аргумента в массиве  argv . При этом следует учитывать, что  getopt() перемещает все свободные аргументы в конец  argv . Таким образом, они оказываются в диапазоне между  optind и  argc-1 . Если optind больше или равно  argc, то это означает, что свободные аргументы отсутствуют.

Рассмотрим пример программы, которая выводит каждый переданный ей свободный аргумент в отдельной строке (листинг 2). Опция  -o будет перенаправлять вывод в файл, имя которого указывается в зависимом аргументе. А флаг  -h будет выводить краткую справку по работе с программой.

Листинг 2. Программа getoptdemo.c
```cpp
#include <stdio.h>
#include <getopt.h>
int main (int argc, char ** argv)
{
    FILE * outfile = stdout;
    int i, opt;
    char * filename = NULL;
    char help_str[] =
        "Usage: getoptdemo [OPTIONS] ARGUMENTS ...\n"
        "-h — Print help and exit\n"
        "-o <outfile> — Write output to file\n";
    while ((opt = getopt (argc, argv, "ho:")) != -1) {
        switch (opt) {
            case 'h':
                printf ("%s", help_str);
                return 0;
            case 'o':
                filename = optarg;
                break;
            case '?':
                fprintf (stderr, "%s", help_str);
                return 1;
            default:
                fprintf (stderr, "Unknown error\n");
                return 1;
        }
    }
    if (optind >= argc) {
        fprintf (stderr,
            "No argument(s) found\n%s", help_str);
        return 1;
    }
    if (filename != NULL) {
        outfile = fopen (filename, "w");
        if (outfile == NULL) {
            fprintf (stderr, "Cannot open "
                "output file (%s)\n", filename);
            return 1;
        }
    }
    for (i = optind; i < argc; i++)
        fprintf (outfile, "%s\n", argv[i]);
    if (outfile != stdout) fclose (outfile);
    return 0;
}
```

Рассмотрим все по порядку. 
- Сначала объявляется файловый указатель `outfile`, который инициализируется значением `stdout`. Эта запись говорит о том, что по умолчанию (если не указана опция -o) вывод будет осуществляться в стандартный вывод. 
- Указатель `filename` несет двойную нагрузку: если указана опция -o, в него будет занесено имя файла; если же в указателе `filename` останется значение NULL, это будет означать, что опция  -o не передавалась.
- Строка `help_str` содержит краткую справку по работе с программой. Если указать опцию  -h , то эта справка будет выводиться в стандартный вывод (stdout). 
- В случае неправильного набора опций или аргументов, справочная информация будет выводиться в стандартный поток ошибок (stderr).

Затем следует цикл обработки опций. Функция `getopt()` вызывается до тех пор, пока не возвратит значение –1, сигнализирующее о том, что все опции обработаны.

Опция -h подразумевает вызов справки и завершение программы, поэтому вместо инструкции `break` стоит  `return`.

Далее обрабатывается опция -o , зависимый аргумент которой (`optarg`) заносится в `filename`. Следующий блок выводит в поток ошибок (`stderr`) справочную информацию и завершает программу, если пользователь ввел неверную опцию. Наконец, если `getopt()` возвратила что-то еще, то выводится сообщение о неизвестной ошибке, и программа завершается.

После выхода из цикла проверяется наличие свободных аргументов. Если таковые отсутствуют, то программа завершается, выводя сообщение об ошибке и справочную информацию в `stderr`. 

Затем проверяется, пожелал ли пользователь перенаправить вывод в файл. Если опция -o была указана, то в  `outfile` заносится указатель на открытый файл. В противном случае вывод будет производиться в `stdout`(стандартный вывод).

## 3. ИСПОЛЬЗОВАНИЕ ДЛИННЫХ ОПЦИЙ

Функция `getopt_long()`, объявленная в заголовочном файле getopt.h, позволяет обрабатывать не только короткие, но и длинные (многосимвольные) опции. Следует заметить, что `getopt_long()` устанавливает правило, по которому длинным опциям предшествует последовательность из двух дефисов ( --version ,  --line-number и т. д.). Итак, функция  getopt_long() имеет следующий прототип:

```cpp
int getopt_long (int ARGC, char ** ARGV,
    const char * SHORT_OPTS,
    const struct option * LONG_OPTS,
    int * OPT_INDEX);
```

Аргументы ARGC, ARGV и SHORT_OPTS аналогичны соответствующим аргументам функции `getopt()` из предыдущего раздела.  LONG_OPTS — это массив структур option , описывающий длинные опции и соответствующие им короткие опции. 

По адресу, находящемуся в  OPT_INDEX, располагается индекс текущей опции в массиве LONG_OPTS. Структура  option состоит из четырех элементов:

```cpp
struct option {
    char * LONG_OPT;
    int WITH_ARG;
    int * OPT_FLAG;
    int SHORT_OPT;
};
```

Строка  LONG_OPT содержит имя длинной опции (без дефисов). Элемент  WITH_ARG может принимать три значения:
- 0 или  no_argument — если опция является флагом, т. е. не требует наличия зависимого аргумента;
- 1 или  required_argument — если опция требует наличия зависимого аргумента;
- 2 или  optional_argument — если зависимый аргумент предполагается, но не является обязательным.

Указатель OPT_FLAG необходим для работы с опциями, не требующими аргументов.

В рамках данной работы мы не будем использовать этот элемент. Если  OPT_FLAG установлен в  NULL, то в  SHORT_OPT заносится код символа соответствующей короткой опции.

Последний элемент массива LONG_OPTS должен содержать только нулевые значения:
LONG_OPT = NULL;
WITH_ARG = 0;
OPT_FLAG = NULL;
SHORT_OPT = 0;

Если в каждом элементе массива LONG_OPTS устанавливать OPT_FLAG в NULL, то функция  getopt_long() будет работать так же, как и  getopt(). 

Рассмотрим в качестве примера программу из предыдущего раздела, добавив в нее возможность обработки длинных опций (листинг 3). Для этого определим следующие соответствия между длинными и короткими опциями:
- длинная опция  --help будет аналогична короткой  -h;
- длинная опция  --output будет аналогична короткой  -o.

Листинг 3. Программа longoptdemo.c
```cpp
#include <stdio.h>
#include <getopt.h>

int main (int argc, char ** argv)
{
    FILE * outfile = stdout;
    int i, opt;
    char * filename = NULL;
    char help_str[] =
        "Usage: longoptdemo [OPTIONS] ARGUMENTS ...\n"
        "-h, --help — Print help and exit\n"
        "-o, --output <outfile> — Write output to file\n";
    const struct option long_opts[] = {
        { "help", no_argument, NULL, 'h' },
        { "output", required_argument, NULL, 'o' },
        { NULL, 0, NULL, 0 }
    };
    while ((opt = getopt_long (argc, argv, "ho:",
        long_opts, NULL)) != -1) {
        switch (opt) {
        case 'h':
            printf ("%s", help_str);
            return 0;
        case 'o':
            filename = optarg;
            break;
        case '?':
            fprintf (stderr, "%s", help_str);
            return 1;
        default:
            fprintf (stderr, "Unknown error\n");
            return 1;
        }
    }
    if (optind >= argc) {
        fprintf (stderr,
            "No argument(s) found\n%s", help_str);
        return 1;
    }
    if (filename != NULL) {
        outfile = fopen (filename, "w");
        if (outfile == NULL) {
            fprintf (stderr, "Cannot open "
                "output file (%s)\n", filename);
            return 1;
        }
    }
    for (i = optind; i < argc; i++)
        fprintf (outfile, "%s\n", argv[i]);
    if (outfile != stdout) fclose (outfile);
        return 0;
}
```

## 4. Получение дополнительной информации
Дополнительную информацию по этой теме можно получить из следующих источников:
- man 3 getopt — man-страница функции  getopt() ;
- man 3 getopt_long — man-страница функции  getopt_long();
- man 3 popt — man-страница библиотеки popt (для доступа к ней может потребоваться установка дополнительных пакетов, таких как libpopt-devel);
- man 1 getopt — man-страница утилиты getopt;
- http://www.gnu.org/software/gengetopt/gengetopt.html — обработчик опций GNU Gengetopt;
- http://www.gnu.org/software/libc/manual/html_node/Argp.html  —  обработчик опций Argp.
